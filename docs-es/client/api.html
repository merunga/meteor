<template name="api">
{{#better_markdown}}

<h1 id="api">La API de Meteor</h1>

Traducción <b>no-oficial</b> al Español 

Su código JavaScript se puede ejecutar en dos entornos: el *client* (browser), y
el *server* (un contenedor [Node.js](http://nodejs.org/) en un server).  Para cada 
función de esta referencia de la API , indicaremos si la función está disponible sólo
en el cliente, sólo en en el servidor, o en cualquier lugar *Anywhere*.

<h2 id="core"><span>Meteor Core</span></h2>

{{> api_box isClient}}
{{> api_box isServer}}
{{> api_box startup}}

En un servidor, la función se ejecutará tan pronto como el proceso del servidor 
ha terminado de iniciarse. En un cliente, la función se ejecutará tan pronto como 
el DOM esté listo.

Los <i>callbacks</i> de `inicio` son llamados en el mismo orden que se hicieron 
las llamadas a `Meteor.startup`.

En un cliente, los <i>callbacks</i> de `startup` desde paquetes inteligentes será llamado 
primero, seguido de las `<body>` templates de sus archivos `.html`,
seguido por el código de su aplicación. 

    // On server startup, if the database is empty, create some initial data.
    // En el arranque del servidor, si la base de datos está vacía,  
    // se crean algunos datos iniciales.
    if (Meteor.isServer) {
      Meteor.startup(function () {
        if (Rooms.find().count() === 0) {
          Rooms.insert({name: "Initial room"});
        }
      });
    }

{{> api_box absoluteUrl}}

{{> api_box settings}}

{{> api_box release}}

<h2 id="publishandsubscribe"><span>Publicar y suscribirse</span></h2>

Estas funciones controlan cómo los servidores Meteor publican conjuntos de registros y
cómo los clientes pueden suscribirse a estos conjuntos.

{{> api_box publish}}

Para publicar registros de los clientes, llame a `Meteor.publish` en el servidor con dos
parámetros: el nombre del conjunto de registros, y  la <i>función de publicación</i> *publish function*
que Meteor llamará cada vez que un cliente se suscriba al nombre.

Las funciones de publicación pueden devolver un 
[`Collection.Cursor`](#meteor_collection_cursor), en tal caso, Meteor 
publicará los documentos de cursor. Usted también puede devolver un <i>array</i> de
`Collection.Cursor`s, en tal caso Meteor publicará todos los cursores.

{{#warning}}
Si usted devuelve múltiples cursores en un array, 
en la actualidad todos deben ser de diferentes colecciones.
Esperamos levantar esta restricción en una versión futura.
{{/warning}}

    // server: publish the rooms collection, minus secret info.
    Meteor.publish("rooms", function () {
      return Rooms.find({}, {fields: {secretInfo: 0}});
    });

    // ... and publish secret info for rooms where the logged-in user
    // is an admin. If the client subscribes to both streams, the records
    // are merged together into the same documents in the Rooms collection.
    Meteor.publish("adminSecretInfo", function () {
      return Rooms.find({admin: this.userId}, {fields: {secretInfo: 1}});
    });

    // publish dependent documents and simulate joins
    Meteor.publish("roomAndMessages", function (roomId) {
      return [
        Rooms.find({_id: roomId}, {fields: {secretInfo: 0}}),
        Messages.find({roomId: roomId})
      ];
    });

En caso contrario, la función de publicación debe llamar a las funciones 
[`added`](#publish_added) (cuando un nuevo documento se añade al conjunto de 
registros publicados), [`changed`](#publish_changed) 
(Cuando algunos campos en un documento en el conjunto de registros se cambian o
borran), y [`removed`](#publish_removed) 
(cuando los documentos se eliminan del conjunto de registros publicados) 
para informar a los suscriptores sobre los documentos.
Estos métodos son proporcionados por `this` en la función de publicación.

<!-- TODO discuss ready -->

Ejemplo:

    // server: publish the current size of a collection
    Meteor.publish("counts-by-room", function (roomId) {
      var self = this;
      var count = 0;
      var initializing = true;
      var handle = Messages.find({roomId: roomId}).observeChanges({
        added: function (id) {
          count++;
          if (!initializing)
            self.changed("counts", roomId, {count: count});
        },
        removed: function (id) {
          count--;
          self.changed("counts", roomId, {count: count});
        }
        // don't care about moved or changed
      });

      // Observe only returns after the initial added <i>callbacks</i> have
      // run.  Now return an initial value and mark the subscription
      // as ready.
      initializing = false;
      self.added("counts", roomId, {count: count});
      self.ready();

      // Stop observing the cursor when client unsubs.
      // Stopping a subscription automatically takes
      // care of sending the client any removed messages.
      self.onStop(function () {
        handle.stop();
      });
    });

    // client: declare collection to hold count object
    Counts = new Meteor.Collection("counts");

    // client: subscribe to the count for the current room
    Deps.autorun(function () {
      Meteor.subscribe("counts-by-room", Session.get("roomId"));
    });

    // client: use the new collection
    console.log("Current room has " +
                Counts.findOne(Session.get("roomId")).count +
                " messages.");

{{#warning}}
Meteor emitirá un mensaje de advertencia si usted llama a `Meteor.publish` en un
proyecto que incluye el paquete `autopublish`. Su función de publicación 
seguirá funcionando.
{{/warning}}

{{> api_box subscription_userId}}
Esto es constante. Sin embargo, si el usuario que ha iniciado sesión, cambia,
la función de publicación se vuelve a ejecutar con el nuevo valor.

{{> api_box subscription_added}}
{{> api_box subscription_changed}}
{{> api_box subscription_removed}}
{{> api_box subscription_ready}}

{{> api_box subscription_onStop}}

Si se llama [`observe`](#observe) o [`observeChanges`](#observe_changes) en su
manejador de publicación, esto es el lugar para detener <i>observes</i>.

{{> api_box subscription_error}}
{{> api_box subscription_stop}}

{{> api_box subscribe}}
 
Cuando se suscribe a un conjunto de registros, le dice al servidor que envie 
información al cliente. El cliente almacena estos archivos en local [Minimongo
collections](#meteor_collection), con el mismo nombre que el argumento `collection`
utilizado con el controlador de publicación los <i>callbacks</i> `added`, `changed`, and `removed`.  
Meteor encolará atributos entrantes hasta que usted declare la
[`Meteor.Collection`](#meteor_collection) en el cliente con el
correspondiente nombre de la colección.

    // Bien para suscribirse (y posiblemente recibir datos) antes de declarar
    // La colección cliente que lo sostendrá.  Asume "allplayers"
    // publica los datos del servidor de la colección "players"
    Meteor.subscribe("allplayers");
    ...
    // colas de cliente registran los <i>players</i> entrantes hasta que ...
    ...
    Players = new Meteor.Collection("players");

El cliente verá un documento si el documento se encuentra actualmente 
en el conjunto de registros publicados de cualquiera de sus suscripciones.

El <i>callback</i> `onReady`  es llamado sin argumentos cuando
el servidor [marca la suscripción como <i>onReady</i>](#publish_ready). 
El <i>callback</i> `onError`  es llamado con un [`Meteor.Error`](#meteor_error) 
si la suscripción falla o es terminada por el servidor.

`Meteor.subscribe` devuelve un identificador de suscripción, que es un objeto
con los siguientes métodos:

<dl class="<i>callbacks</i>">
{{#dtdd "stop()"}}
Cancelar la suscripción. Esto normalmente se traducirá
en el servidor dirigiendose al cliente para eliminar los datos de la suscripción
de la memoria caché del cliente.

{{/dtdd}}

{{#dtdd "ready()"}}
True si el servidor ha [marcó la suscripción como ready](#publish_ready). 
Una fuente de datos reactiva.
{{/dtdd}}
</dl>

Si usted llama `Meteor.subscribe` dentro de una [computación reactiva](#reactivity),
por ejemplo utilizando [`Deps.autorun`](#deps_autorun), 
la suscripción será automáticamente cancelada cuando el cálculo se invalida 
o se detiene, no es necesario llamar `stop` en suscripciones efectuadas 
desde el interior de `autorun`. 
Sin embargo, si en la próxima iteración de la ejecución de su función subscribe el
mismo conjunto de registros  (mismo nombre y parámetros),
Meteor es lo suficientemente inteligente como para evitar el
derroche de un desinscribirse/reinscribirse. 

Por ejemplo:

    Deps.autorun(function () {
      Meteor.subscribe("chat", {room: Session.get("current-room")});
      Meteor.subscribe("privateMessages");
    });
 
Esto le suscribe a los mensajes de chat en la sala actual y a tus
mensajes privados. Cuando cambie de habitación llamando 
`Session.set("current-room", "new-room")`, 
Meteor se suscribirá a los mensajes de la nueva sala de chat, 
se dará de baja de los mensajes de la sala original
y se mantendrá suscrito a sus mensajes privados. 

Si más de una suscripción envía valores en conflicto para un campo (el mismo
nombre de la colección, ID de documento, y el nombre de campo), entonces el valor en el
cliente será uno de los valores publicados, elegido arbitrariamente.

<h2 id="methods_header"><span>Methods</span></h2>

Los métodos son funciones remotas que los clientes Meteor pueden invocar.

{{> api_box methods}}

Ejemplo:

    Meteor.methods({
      foo: function (arg1, arg2) {
        // .. hacer algo..
        if (quiere lanzar un error)
          throw new Meteor.Error(404, "No puedo encontrar mi pantalones");
        return "se devuelve algún valor";
      },
      
      bar: function () {
        // ..  hacer otra cosa..
        return "baz";
      }
    });

Llamando `methods` en las funciones definidas en el
servidor que pueden ser llamados de forma remota por los clientes.

  Deben devolver un [EJSON](#ejson)-able valor o lanzar una
excepción. Dentro del método de invocación, `this` se une a un objeto 
del método de invocación, el cual presenta lo siguiente:

* `isSimulation`: un valor  booleano, true si esta invocación es un <i>stub</i>.
* `unblock`: cuando se le llama, permite que el método siguiente de este cliente 
empiece a ejecutarse.
* `userId`: el id del usuario actual.
* `setUserId`: una función que asocia el cliente actual con un usuario.

Llamar a `methods` en el cliente define funciones *stub* asociadas con 
los métodos de servidor del mismo nombre. Usted no tiene que definir un stub 
para su método si no desea hacerlo. En ese caso, las llamadas a métodos son 
como las llamadas a procedimientos remotos en otros sistemas,
y usted tendrá que esperar los resultados del servidor. 

Si usted define un <i>stub</i>, cuando un cliente invoca un método del servidor
también lo hará su <i>stub</i> en paralelo. En el cliente, el valor de retorno de
un <i>stub</i> es ignorado. <i>Stubs</i> se ejecutan por sus efectos secundarios:

están destinados a *simular* el resultado de lo que el método del servidor va a hacer
pero sin esperar el retardo de ida y vuelta.Si un <i>stub</i> lanza una 
excepción que será registrada en la consola.

Se utilizan métodos todo el tiempo, porque los mutadores de bases de datos
([`insert`](#insert), [`update`](#update), [`remove`](#remove)) están implementdos
como métodos. Cuando se llama cualquiera de estas funciones en el cliente, 
se está invocando su versión de <i>stub</i> que actualiza la memoria caché local, 
y envía la misma petición de escritura al servidor. Cuando el servidor responde, 
el cliente actualiza la caché local con lo que se ha escrito realmente en el servidor.

{{> api_box method_invocation_userId}}

El ID de usuario es una cadena arbitraria &mdash; típicamente el id de registro 
del usuario en la base de datos. Usted puede establecerlo con la función`setUserId` 
Si está utilizando las cuentas [Meteor accounts system](#accounts_api) 
entonces esto es manejado por usted.

{{> api_box method_invocation_setUserId}}

Llame esta función para modificar el actual usuario conectado 
en la conexión que hizo esta llamada al método.
Esto simplemente establece el valor de `userId` para futuras llamada al método
recibidas en esta conexión. Pase `null` para salir <i>log out</i> de la conexión.

Si usted está utilizando el [built-in Meteor accounts system](#accounts_api) 
entonces este debe corresponder al campo `_id` del documento en la colección
[`Meteor.users`](#meteor_users).

`setUserId` no es retroactivo. Afecta a la llamada al método actual 
y cualquier futura llamada al método en la conexión.
Cualquier anterior llamada al método en esta conexión seguirá viendo el valor de
`userId` que estaba vigente cuando comenzaron.

{{> api_box method_invocation_isSimulation}}

{{> api_box method_invocation_unblock}}

En el servidor, métodos de un cliente dado se ejecutan uno a la vez. 
La invocación Nº 1 de un cliente, no se iniciará hasta que la invocación enésima
retorne.
Sin embargo, usted puede cambiar esto llamando `this.unblock`. 
Esto permitirá que la invocación N+1th  empiece a ejecutarse  en
una nueva fibra.

{{> api_box error}}

Si desea devolver un error desde un método, lanze una excepción. 
Los métodos pueden arrojar cualquier tipo de excepción.
Pero `Meteor.Error` es la única clase de excepción que el servidor enviará al
cliente. Si una función método lanza una excepción diferente, entonces será
asignada a `Meteor.Error(500, "Internal server error")` <i>on the wire.</i> al momento.

{{> api_box meteor_call}}

Esta es la forma de invocar un método  Se ejecutará el método en el servidor.  Si un 
<i>stub</i> está disponible, tambien ejecutará el <i>stub</i> en el cliente.  (Ver 
también [`Meteor.apply`](#meteor_apply), que es idéntico a `Meteor.call` excepto que
usted specifique los parametros como un <i>array</i> en lugar de como argumentos 
separados y puede especificar varias opciones controlando cómo se ejecuta el método.)

Si usted incluye una función <i>callback</i> como último argumento (que no puede ser un 
argumento para el método, ya que las funciones no son serializables),
el método se ejecutará de forma asíncrona: no retornará nada en particular 
y no lanzará una excepción. Cuando el método se haya completado (que puede 
o no puede suceder antes de que `Meteor.call` retorne), el <i>callback</i> se invocará
con dos argumentos: `error` and `result`. Si un error fue lanzado, entonces
`error` será el objeto excepción. De lo contrario, `error` será indefinido y
el valor de retorno (posiblemente indefinido, <i>undefined</i>) estará en `result`.

    // async call
    Meteor.call('foo', 1, 2, function (error, result) { ... } );

Si usted no pasa un "<i>callback</i>" al servidor, la invocación del método se 
bloqueará hasta la conclusión del método. Eventualmente se devolverá el valor 
de retorno del método, o será una excepción si el método arrojó una <i>exception</i> 

or it will throw an exception if the method
threw an exception. (Posiblemente asignada a 500 Server Error si la
excepción ocurrió remotamente y no fuera una excepción `Meteor.Error`.)

    // sync call
    var result = Meteor.call('foo', 1, 2);

En el cliente, si usted no pasa un <i>callback</i> y no esta en el interior de un stub,
`call` retornará `undefined`, y usted no tendrá manera de obtener el valor de retorno 
del método. Esto es porque el cliente no tiene fibras, así que no hay realmente ninguna
manera que se pueda bloquear la ejecución remota de un método 

Por último, si usted está dentro de un <i>stub</i> en el cliente y llama otro
método, el otro método no es ejecutado (RPC no se genera, nada
"real" sucede). Si ese otro método tiene un <i>stub</i>, ese <i>stub</i> sustituye al 
del método y se ejecuta. El valor de retorno de la llamada al método es el valor de retorno 
de la función stub.  El cliente no tiene nungún problema en la ejecución de un <i>stub</i> 
sincrónicamente, y es por eso que está bien que el cliente utilice la forma sincrona 
`Meteor.call` dentro de un cuerpo de método, como se describió anteriormente.

Meteor hace un seguimiento en la base de datos de las escrituras realizadas por métodos,
tanto en el cliente como en el servidor, y no invoca `async<i>callback</i>` 
hasta que todas las escrituras en el servidor reemplazan las escrituras del stub's
en la <i>caché</i> local. En algunos casos, puede haber un retraso entre el valor devuelto 
por el método que está disponible y las escrituras que son visibles: por ejemplo, si otro 
método aún pendiente escribieró en el mismo documento la memoria caché local puede 
no estar actualizada hasta que el otro método finaliza también. Si quieres procesar el 
resultado del método tan pronto como llegue del servidor,  incluso si la escritura del 
método no está disponibles todavía, usted puede especificar un 
`onResultReceived` <i>callback</i> a [`Meteor.apply`](#meteor_apply).

{{> api_box meteor_apply}}

`Meteor.apply` es lo mismo que `Meteor.call`, excepto que los argumentos del método son 
pasados como un <i>array</i> en vez de hacerlo directamente como argumentos, y puede especificar
las opciones acerca de como el cliente ejecuta el método.

<h2 id="connections"><span>Server connections</span></h2>

Estas funciones gestionan y controlan la conexión de red entre el cliente Meteor y el servidor. 


{{> api_box status}}

Este método devuelve el estado de la conexión entre el cliente y el servidor. 
El valor de retorno es un objeto con los siguientes campos:

<dl class="objdesc">
{{#dtdd name="connected" type="Boolean"}}
  <i>True</i> si está conectado actualmente al servidor. Si <i>false</i>, cambia 
  y las invocaciones de método se pondrán en cola hasta que la conexión se restablezca. 
{{/dtdd}}

{{#dtdd name="status" type="String"}}
  Describe el estado actual de la reconexión. Los valores posibles
  son `connected` (la conexión está en funcionamiento),
  `connecting` (desconectado e intentando abrir una nueva conexión), 
  `failed` (el intento de conectar falla permanentemente; e.g., el cliente
  y el servidor soportan diferentes versiones de <i>DDP</i>) 
  y `waiting` (intento de conexión fracasado y esperando para intentar reconectarse).
{{/dtdd}}

{{#dtdd name="retryCount" type="Number"}}
  El número de veces que el cliente ha inentado reconectarse desde que la 
  conexiónn se perdió. 0 cuando está conectado.
{{/dtdd}}

{{#dtdd name="retryTime" type="Number or undefined"}}
  El tiempo estimado del siguiente intento de reconexión. Para convertir esto
  en un intervalo hasta la próxima reconexión, utilice 
  `retryTime - (new Date()).getTime()`. Esta clave se 
  establece sólo cuando `status` es `waiting`.
{{/dtdd}}

{{#dtdd name="reason" type="String or undefined"}}
  Si `status` es `failed`, una descripción de ¿Por qué falló la conexión?. 
{{/dtdd}}
</dl>

En vez de utilizar <i>callbacks</i> para notificarle los cambios, esto es
una fuente de datos [reactive](#reactivity). Se puede utilizar en un
[template](#templates) o [computation](#deps_autorun)
para obtener actualizaciones en tiempo real.

{{> api_box reconnect}}

{{> api_box connect}}

Para llamar a métodos en otra aplicación Meteor o suscribirse a sus
conjuntos de sus datos, llame `Meteor.connect` con la dirección URL de la aplicación.
`Meteor.connect` devuelve un objeto que proporciona:

* `subscribe` -
  Suscribirse a un conjunto de registros. Ver
  [Meteor.subscribe](#meteor_subscribe).
* `call` -
  Invocar un método. Ver [Meteor.call](#meteor_call).
* `apply` -
  Invocar un método con un array de argumentos. Ver
  [Meteor.apply](#meteor_apply).
* `methods` -
  Definir sólo-cliente stubs par métodos definidos en el servidor remotoe. Ver
  [Meteor.methods](#meteor_methods).
* `status` -
  Obtener el estado actual de la conexión. Ver
  [Meteor.status](#meteor_status).
* `reconnect` -
  Ver [Meteor.reconnect](#meteor_reconnect).
* `onReconnect` - Ponga esto en la función que se llame como primer paso para reconectar.
  Esta función puede llamar a los métodos, que se ejecutarán antes de cualquier 
  otro método pendiente. Por ejemplo,esto se puede utilizar para volver a reestablecer
  el contexto de autenticación adecuado en la nueva conexión.

Por defecto, los clientes abren una conexión con el servidor desde el que están cargados.
When you call `Meteor.subscribe`, `Meteor.status`, `Meteor.call`, y
`Meteor.apply`, usted está utilizando una conexión, de nuevo, con el servidor por defecto.

{{#warning}}
En esta versión, `Meteor.connect` sólo puede ser llamado en el cliente.
Los Servidores no pueden todavía conectarse a otros servidores.
{{/warning}}

<h2 id="collections"><span>Collections</span></h2>

Meteor almacena los datos en *collections*. Para empezar, declare una
colección con `new Meteor.Collection`.

{{> api_box meteor_collection}}

Llamar esta función es análoga a la declaración de un modelo en un tradicional framework ORM
(Object-Relation Mapper)-céntrica . Se establece una *collection* (un espacio de almacenamiento 
de registros, o "documentos") que pueden ser utilizados para almacenar un tipo particular 
de información, como usuarios, <i>posts</i>, puntuaciones, tareas pendientes,
o cualquier cosa importante para su aplicación.  
Cada documento es un objeto EJSON. Incluye un `_id` con la
propiedad de ser un valor único en la colección,
que Meteor especificó al crear el documento.

    // código común en el cliente y el servidor <i>livedata-managed</i>
    // coleción mongo.
    Chatrooms = new Meteor.Collection("chatrooms");
    Messages = new Meteor.Collection("messages");

La función devuelve un objeto con métodos para [`insert`](#insert)
los documentos de la colección, [`update`](#update) sus propiedades, y
[`remove`](#remove), y a [`find`](#find) los documentos de la
colección que coincidan con criterios arbitrarios. la forma en que estos métodos trabajan es
compatible con el popular <i>Mongo database API</i>. La misma <i>database API</i>
 funciona tanto en el cliente como en el servidor (ver abajo).

    // return array of my messages
    var myMessages = Messages.find({userId: Session.get('myUserId')}).fetch();

    // create a new message
    Messages.insert({text: "Hello, world!"});

    // mark my first message as "important"
    Messages.update(myMessages[0]._id, {$set: {important: true}});

Si usted pasa un `name` cuando crea la colección, entonces está 
declarando una colección persistente &mdash; que se almacena en 
el servidor y es visto por todos los usuarios. Ambos el código de cliente 
y el de servidor pueden acceder a la misma colección utilizando la misma <i>API</i>.

Especificamente, cuando usted pasa un `name`, esto es lo que sucede:

* En el servidor, una colección con este nombre se crea en un servidor <i>back-end</i> Mongo. 
Cuando llame métodos en esta colección en el servidor,
 When you call methods on that collection en el servidor,
se traducen directamente en las operaciones normales de Mongo (después de comprobar 
que coinciden con sus [reglas de control de acceso](#allow)).

* En el cliente, una instancia Minimongo es
creada. Minimongo es esencialmente una implementación no persistente, 
en memoria, de Mongo en JavaScript puro. 
 Sirve una caché local que almacena sólo el subconjunto de la base de datos
de la que este cliente está trabajando.
Las consultas sobre el cliente ([`find`](#find))se sirven directamente de
esta caché, sin hablar con el servidor.

* Cuando usted escriba en la base de datos del cliente ([`insert`](#insert),
[`update`](#update), [`remove`](#remove)), el comando se ejecuta
inmediatamente en el cliente, y, simultaneamente, se envían al
al servidor y se ejecutan tambien allí. El paquete `livedata` es el
responsable de esto.

Si pasa `null` como el `name`, entonces usted va a crear una colección local.
collection. Que no es sincronizada en ningún lugar; es sólo una memoria local,
que soporta las operaciones <i>Mongo-style</i> [`find`](#find), [`insert`](#insert),
[`update`](#update), y [`remove`](#remove). (En ambos el
cliente y el servidor, Esta memoria local se implementa mediante Minimongo.

De forma predeterminada, Meteor publica automáticamente todos los documentos de su colección 
para cada cliente conectado.  Para desactivar este comportamiento, quite el
el paquete `autopublish`:

    $ meteor remove autopublish

y llame en su lugar [`Meteor.publish`](#meteor_publish) para especificar qué partes de su
colección deben ser publicados y para que usuarios.

    // Crear una colección llamada <i>Posts</i> y poner un documento en él. El
    // documento será immediatamente visible en la copia local de la
    // colección. Se escribirá en la base de datos <i>server-side</i>
    // una fracción de segundo más tarde, y una fracción de segundo
    // después de eso, se sincronizará con los otros clientes
    // que se esten suscritos a una consulta que los incluya (Ver
    // Meteor.subscribe and autopublish)
    Posts = new Meteor.Collection("posts");
    Posts.insert({title: "Hello world", body: "First post"});

    // Los cambios son visibles de inmediato -- sin esperara a un ida y vuelta <i>round trip</i>
    // al servidor
    assert(Posts.find().count() === 1);

    // Crea una colección local, temporal. Funciona como cualquier otra
    // colección, pero no envía los cambios al servidor, y no    
    // puede recibir ningún dato de los suscriptores.
    Scratchpad = new Meteor.Collection;
    for (var i = 0; i < 10; i++)
      Scratchpad.insert({number: i * 2});
    assert(Scratchpad.find({number: {$lt: 9}}).count() === 5);

Si especifica una opción `transform` a la `Collection` o cualquiera de sus
métodos de recuperación, los documentos se pasan a través de la función `transform` 
antes de ser retornados o pasados a los <i><i>callbacks</i></i>. Esto le permite añadir métodos 
o por otra parte modificar el contenido de su colección desde la representación de su 
base de datos. También puede especificar `transform` en una determinada llamada a `find`, 
`findOne`, `allow`, o `deny`.

    // Una clase de animal que obtiene un documento en su constructor
    Animal = function (doc) {
      _.extend(this, doc);
    };
    _.extend(Animal.prototype, {
      makeNoise: function () {
        console.log(this.sound);
      }
    });

    //Define una colección que utiliza Animal como documento
    Animals = new Meteor.Collection("Animals", {
      transform: function (doc) { return new Animal(doc); }
    });

    // Crear un Animal y llamar a su método <i>makeNoise</i>
    Animals.insert({name: "raptor", sound: "roar"});
    Animals.findOne({name: "raptor"}).makeNoise(); // prints "roar"

Las funciones `transform` no son llamadas reactivamente. Si quiere añadir un atributo 
que cambie dinámicamente a un objeto, hágalo con una función que calcule el valor en 
el momento que se llama, no computando el atributo `transform` al momento.

{{#warning}}
<<<<<<< HEAD
En esta versión, Minimongo tiene algunas limitaciones:

* `$pull` en modificadores sólo puede aceptar ciertos
tipos de selectores.
* `$` referirse a la posición de array que coincide no está soportado en modifier.
* `findAndModify`, funciones upsert, aggregate, y
map/reduce no estan suportadas.

Todo esto se abordará en una próxima versión. 
Para notas completas de la versión Minimongo, consulte
Ver packages/minimongo/NOTES en el repositorio.
=======
In this release, Minimongo has some limitations:

* `$pull` in modifiers can only accept certain kinds
of selectors.
* `$` to denote the matched array position is not
supported in modifier.
* `findAndModify`, upsert, aggregate functions, and
map/reduce aren't supported.

All of these will be addressed in a future release. For full
Minimongo release notes, Ver packages/minimongo/NOTES
in the repository.
>>>>>>> 57274449dfc943064d4a299dbe3011578f2b1758
{{/warning}}

{{#warning}}
Minimongo actualmente no tienen índices. Es raro que esto sea un problema,
ya que es inusual que un cliente tenga datos suficientes para que un índice 
valga la pena.
{{/warning}}

{{> api_box find}}

`find` devuelve un cursor.  No tiene acceso inmediato a la base de datos 
o devuelve documentos.  Los cursores proporcionan `fetch` para retornar 
todos los documentos coincidentes, `map` y `forEach` para iterar sobre 
todos los documentos coincidentes, y `observe` y `observeChanges` 
para registrar <i>callbacks</i> cuando el conjunto de documentos coincidente cambia.

{{#warning}}
La colección de cursores no son instantáneas de la consulta.  Si la base de 
datos cambia entre llamadas `Collection.find` y extraer los resultados de
del cursor, o mientras obtiene resultados desde el cursor,
estos cambios pueden o no puede aparecer en el conjunto de resultados.
{{/warning}}

Cursor es una fuente de datos reactivo. La primera vez que recupera n
documentos de cursor con `fetch`, `map`, o `forEach` dentro de una 
computación reactiva (ej, una plantilla o 
[`autorun`](#deps_autorun)),  Meteor registrará una 
dependencia de los datos subyacentes.
Cualquier cambio en la colección que cambia los documentos en un cursor 
disparará un recálculo. Para desactivar este comportamiento, pase
`{reactive: false}` como una opción para `find`.

{{> api_box findone}}

Equivalente a `find(selector, options).fetch()[0]`.

{{> api_box insert}}

Añade un documento a la coleccion. Un documento es sólo un objeto, y
y sus campos pueden contener cualquier combinación de tipos de datos
 EJSON-compatible (arrays, objects, numbers, strings, `null`, true, and false).

`insert` generará un ID único para el objeto que usted pase, lo inserta
en la base de datos, y retorna el ID. Cuando `insert` se llama desde
código de cliente no confiable, se le permitirá sólo si pasa cualquier
regla aplicable [`allow`](#allow) y [`deny`](#deny).

En el servidor, si no proporciona un <i>callback</i>, entonces  `insert` bloques
que la base de datos reconozca la escritura, o se produzca una excepción si
algo salió mal.  Si  proporciona un <i>callback</i>, `insert` sigue devolviendo 
el ID de inmediato. Una vez que la inserción se completa (o falla),
el <i>callback</i> es llamado con argumentos de error y resultado.  En caso de error,
`result` es indefinido.  Si la insercion tiene éxito, `error` es
indefinido y `result` es el nuevo ID de documento.

En el cliente, `insert` nunca bloquea.  Si usted no provee un <i>callback</i>
y la inserción falla en el servidor, entonces Meteor registrará un <i>warning</i> en
la consola.  Si  provee un <i>callback</i>, Meteor llamará esa función con argumentos
`error` y `result`. En caso de error, `result` es indefinido.  
Si la inserción tiene éxito, `error` es indefinido y `result` es el nuevo ID de documento.

Ejemplo:

    var groceriesId = Lists.insert({name: "Groceries"});
    Items.insert({list: groceriesId, name: "Watercress"});
    Items.insert({list: groceriesId, name: "Persimmons"});

{{> api_box update}}

Modificar documentos que coinciden con `selector` según `modifier` (Ver
[modifier documentation](#modifiers)).

El comportamiento de `update` difiere dependiendo de si se es llamado por 
código confiable o código no confiable. Código confiable incluye código 
del servidor y código de método. Código no confiable incluye código <i>client-side</i>
tales como controladores de eventos y un navegador con consola JavaScript.

- El código confiable puede modificar varios documentos a la vez estableciendo
  `multi` a <i>true</i>, y puede utilizar un arbitrario [Mongo
  selector](#selectors) para encontrar los documentos que desea modificar. 
  Se pasan por alto las reglas de control de acceso establecidos por
  [`allow`](#allow) y [`deny`](#deny).

- El código no confiable sólo puede modificar un documento único a la vez, especificado 
  por sus `_id`. La modificación se permite sólo después de comprobar cualquier
  regla aplicable [`allow`](#allow) y [`deny`](#deny).

En el servidor, si usted no proporciona un <i>callback</i>,, entonces `update` se bloquea
hasta que la base de datos reconoce la escritura, o lanza una excepción si algo salió mal.
Si usted proporciona un <i>callback</i>,, `update` retorna immediatamente.  
Una vez finalizada la actualización, el <i>callback</i> se llama con un único argumento de error en
el caso de fallo, o sin argumentos si la actualización se ha realizado correctamente.

En el cliente, `update` nunca bloquea.  Si usted no provee un <i>callback</i>
y la actualización falla en el servidor, entonces Meteor registrará un <i>warning</i> en
la consola.  Si  provee un <i>callback</i>,  Meteor llamará esa función con 
un argumento error si hubiera un error, o sin argumentos si la actualización tuvo éxito.

Ejemplo en cliente:

    // Cuando el botón <i>givePoints</i> en el <i>dashboard</i> de administración es pulsado,
    // aumenta 5 puntos al jugador actual. La nueva puntuación será
    // inmediatamente visible en las pantallas de todo el mundo.
    Template.adminDashboard.events({
      'click .givePoints': function () {
        Players.update(Session.get("currentPlayer"), {$inc: {score: 5}});
      }
    });

Ejemplo de servidor:

    // Dar la tarjeta "Winner" a cada usuario con una puntuación superior a 
    // 10. Si está conectado y su lista de tarjeras está visible en
    // pantalla, se actualizará automáticamente mientras se está viendo.
    Meteor.methods({
      declareWinners: function () {
        Players.update({score: {$gt: 10}},
                       {$addToSet: {badges: "Winner"}},
                       {multi: true});
      }
    });

{{#warning}}
La característica Mongo `upsert` no está implementada.
{{/warning}}

{{> api_box remove}}

Encuentra todos los documentos que coinciden con `selector` y los elimina de la colección.

El comportamiento de `remove` difiere dependiendo de si se es llamado po
código confiable o no confiable. Código confiable incluye código 
de servidor y código de método. Código no confiable incluye código <i>client-side</i>
tales como controladores de eventos y un navegador con consola JavaScript.

- El código confiable puede un arbitrario [Mongo selector](#selectors)
  para encontrar los documentos que desea eliminar, y puede eliminar más de un documento
  a la vez passando un selector con el que coincidan multiples documentos.
  Se pasan por alto las reglas de control de acceso establecidos por  
  [`allow`](#allow) y [`deny`](#deny).

  Como medida de seguridad, si se omite `selector` (o es `undefined`),
  ningún documento será eliminado. Establezca `selector` a `{}` si realmente desea
  eliminar todos los documentos de su colección.

- El código no confiable sólo puede eliminar un documento único a la vez, especificado 
  por sus `_id`. El documento es eliminado sólo después de comprobar cualquier
  regla aplicable [`allow`](#allow) y [`deny`](#deny).
  
En el servidor, si usted no proporciona un <i>callback</i>, entonces `update` se bloquea
hasta que la base de datos reconoce la escritura, o lanza una excepción si algo salió mal.
Si usted proporciona un <i>callback</i>, `update` retorna immediatamente.  
Una vez finalizada la actualización, el <i>callback</i> se llama con un único argumento de error en
el caso de avería, o sin argumentos si la actualización se ha realizado correctamente.

En el servidor, si usted no proporciona un <i>callback</i>, entonces `remove` se bloquea
hasta que la base de datos reconoce la escritura, o lanza una excepción si algo salió mal.
Si usted proporciona un <i>callback</i>, `remove` retorna immediatamente.  
Una vez completado el borrado, the <i>callback</i> se llama con un único argumento de error en
el caso de error, o sin argumentos si el borrado se ha realizado correctamente.

En el cliente, `remove` nunca se bloquea.  Si usted no provee un <i>callback</i>
y el borrado falla en el servidor, entonces Meteor registrará un <i>warning</i> en
la consola.  Si  provee un <i>callback</i>,  Meteor llamará esa función con 
un argumento error si hubiera un error, o sin argumentos si el borrado tuvo éxito.

Ejemplo en cliente:

    // Cuando el botón de borrado es clicado en un mensage de chat, elimina
    // ese mensage.
    Template.chat.events({
      'click .remove': function () {
        Messages.remove(this._id);
      }
    });

Ejemplo de servidor:

    // Cuando el servidor comienza, limpia el <i>log</i>, y eliminar a todos los <i>players</i>
    // con un karma menor que -2.
    Meteor.startup(function () {
      if (Meteor.isServer) {
        Logs.remove({});
        Players.remove({karma: {$lt: -2}});
      }
    });

{{> api_box allow}}

Cuando un cliente llama `insert`, `update`, o `remove` en una colección, los
<i>callbacks</i> de las colecciones `allow` y [`deny`](#deny) se invocan en el
servidor para determinar si la escritura se debe permitir. Si al menos
un <i>callback</i> `allow` permite la escritura, y ningún <i>callback</i> `deny` niega la
escritura, entonces, se permite proceder con la escritura.

Estos controles se realizan sólo cuando un cliente intenta escribir en 
la base de datos directamente, por ejemplo llamando `update` desde el interior 
de un controlador de eventos. El código de servidor es confiable y no está 
sujeto a las restrictions `allow` y `deny`. Que incluye métodos que son llamados con
`Meteor.call` &mdash; que se espera que hagan su propio control de acceso en lugar 
de depender de `allow` y `deny`.

Usted puede llamar `allow` tantas veces como quiera,  y cada llamada
puede incluir cualquier combinación de las funciones `insert`, `update`, y `remove`. 
Las funciones deben devolver `true` si piensan que la operación se debe permitir. 
De lo contrario, debe devolver `false`, o nada en absoluto (`undefined`). 
En ese caso Meteor continuará buscando a través de cualquier otra regla de 
la colección.

Los <i><i>callbacks</i></i> disponibles son:

<dl class="<i>callbacks</i>">
{{#dtdd "insert(userId, doc)"}}
El usuario `userId` quiere insertar el documento `doc` en la
colección. Retorna `true` si esto debe ser permitido.
{{/dtdd}}

{{#dtdd "update(userId, doc, fieldNames, modifier)"}}

El usuario `userId` quiere actualizar un documento `doc`. (`doc` es la
versión actual of del documento desde la base de datos, sin la actualización 
propuesta.) Devuelve `true` para permitir el cambio.

`fieldNames` es un array de los campos (top-level) en `doc` que el cliente 
quiere modificar, por ejemplo
`['name',`&nbsp;`'score']`. `modifier` es el modificador raw Mongo que
el cliente quiere ejecutar, por ejemplo `{$set: {'name.first':
"Alice"}, $inc: {score: 1}}`.

Sólo los modificadores Mongo están soportados (operaciones como `$set` y `$push`).
Si el usuario intenta reemplazar el documento completo en lugar de usar
$-modifiers, la solicitud será denegada sin comprobar las funciones `allow`.

{{/dtdd}}

{{#dtdd "remove(userId, doc)"}}

El usuario `userId` quiere borrar `doc` de la base de datos. Retorna
`true` para permitir esto.

{{/dtdd}}

</dl>

Cuando se llama `update` o `remove` Meteor por defecto extraerá el
documento completo  `doc` de la base de datos. Si tiene documentos de gran tamaño
podría desear extraer sólo los campos que sean realmente utilizadas por sus
funciones. Lograr esto mediante el establecimiento de `fetch` a un array de nombres
de campos por recuperar.

Ejemplo:

    // Crea una colección donde los usuarios sólo puedan modificar documentos que
    // que poseen.  La propiedad es rastreada por un campo 'owner' en cada
    // documento. Todos los documentos deben ser propiedad del usuario que los creó
    // y la propiedad no se puede cambiar. Sólo el propietario de un documento
    // tiene permiso para eliminarlo, y el atributo 'locked'  se puede
    // establecer en un documento para evitar su borrado accidental.

    Posts = new Meteor.Collection("posts");

    Posts.allow({
      insert: function (userId, doc) {
        // El usuario debe estar registrado, y el documento debe ser propiedad del usuario
        return (userId && doc.owner === userId);
      },
      update: function (userId, doc, fields, modifier) {
        // sólo puede cambiar sus propios documentos
        return doc.owner === userId;
      },
      remove: function (userId, doc) {
        // sólo puede cambiar sus propios documentos
        return doc.owner === userId;
      },
      fetch: ['owner']
    });

    Posts.deny({
      update: function (userId, docs, fields, modifier) {
        // no se puede cambiar de propietario
        return _.contains(fields, 'owner');
      },
      remove: function (userId, doc) {
        // no se puede eliminar documentos bloqueados
        return doc.locked;
      },
      fetch: ['locked'] // no hay necesidad de buscar "propietario"
    });

Si nunca establece ninguna regla `allow` en una colección entonces que 
cualquier cliente escriba en la colección se puede denegar, y sólo será posible 
escribir en la colección con código del lado del servidor <i>server-side</i>. 
En este caso, usted tendrá que crear un método para cada escritura posible que 
los clientes tengan permitido hacer. Por consiguiente, llame a estos métodos con 
`Meteor.call` en lugar de que los clientes llamen a `insert`, `update`, 
y `remove` directamente en la colección.

Meteor también tiene un especial "insecure mode" para el rápido prototipado 
de nuevas aplicaciones. En el modo no seguro, si no se ha establecido ninguna
regla `allow` o `deny` en una colección entonces todos lo usuarios tienen pleno
acceso de escritura en la colección.
then all users have full write access to the
collection. Este es el único efecto del modo no seguro. Si llama `allow` o
`deny` en todos en una colección, incluso `Posts.allow({})`, entonces el acceso 
se comprueba justo de manera normal en esa colección.
__Los nuevos projectos Meteor se inician en modo inseguro
 por defecto.__ Para desactivarlo basta con ejecutar `$ meteor remove insecure`.

{{> api_box deny}}

Esto funciona igual que [`allow`](#allow), excepto que le permite asegurarse de
que ciertas escriuras son definitivamente denegadas, incluso si hay una regla
`allow`  que dice que se debe permitir. Cuando un cliente intenta
escribir en una colección, el servidor comprueba primero las reglas `deny` 
de la colección. Si ninguna de ellas retorna <i>true</i> entonces se comprueban
reglas `allow` de la colección. Meteor permite la escritura sólo si no hay
reglas `deny` retorna `true` y al menos una regla `allow` retorna `true`.

<h2 id="meteor_collection_cursor"><span>Cursors</span></h2>

Para crear un cursor, utilice [`find`](#find).  Para acceder a los documentos en un
cursor, utilice [`forEach`](#foreach), [`map`](#map), o [`fetch`](#fetch).

{{> api_box cursor_foreach}}

Cuando se llama desde una computación reactiva, `forEach` registra las dependencias 
de los documentos coincidentes.

Ejemplos:

    // Imprime los títulos de las cinco mensajes de puntuación superior
    var topPosts = Posts.find({}, {sort: {score: -1}, limit: 5});
    var count = 0;
    topPosts.forEach(function (post) {
      console.log("Title of post " + count + ": " + post.title);
      count += 1;
    });

{{> api_box cursor_map}}

Cuando se llama desde una computación reactiva, `map` registra las dependencias 
de los documentos coincidentes.
n
<!-- Lo siguiente no se ha implementado todavía, pero los usuarios no deben asumir
ejecución secuencial de todos modos porque romperá. -->
En el servidor, si, `<i>callback</i>` cede, otras llamadas `<i>callback</i>` pueden ocurrir mientras 
la primera llamada está esperando. Si una estricta ejecución secuencial es necesaria, 
use `foreach` en su lugar.

{{> api_box cursor_fetch}}

Cuando se llama desde una computación reactiva, `fetch` registra las dependencias 
de los documentos coincidentes.

{{> api_box cursor_count}}

    // Muestra un recuento de los mensajes que coincidan con determinados criterios. 
    //Automaticamente  lo mantiene actualizado con los cmbios de la base de datos.
    var frag = Meteor.render(function () {
      var highScoring = Posts.find({score: {$gt: 10}});
      return "<p>There are " + highScoring.count() + " posts with " +
        "scores greater than 10</p>";
    });
    document.body.appendChild(frag);

A diferencia de las otras funciones, `count` registra una dependencia sólo 
del número de documentos que coinciden. Las actualizaciones que acaban de cambiar
o reordenar los documentos en el conjunto de resultados no dará lugar a un 
recálculo.)

{{> api_box cursor_rewind}}

Los métodos `forEach`, `map`, or `fetch`  sólo pueden ser llamados una vez en un
cursor. Para acceder a los datos en un cursor más de una vez, utilice 
 `rewind` para restablecer el cursor.

{{> api_box cursor_observe}}

Establecer un *live query* que invoca <i><i>callbacks</i></i> cuando el resultado de la 
consulta cambia. Los <i><i>callbacks</i></i> reciben todo el contenido del documento que 
fue afectado, así como su contenido anterior, si procede. Si sólo necesita recibir
los campos que han cambiado, ver [`observeChanges`](#observe_changes).

Los `<i>callbacks</i>` pueden tener las siguientes funciones como propiedades: 


<dl class="<i>callbacks</i>">
<dt><span class="name">added(document)</span> <span class="or">or</span></dt>
<dt><span class="name">addedAt(document, atIndex, before)</span></dt>
<dd>
{{#better_markdown}}
Un nuevo documento `document` ha entrado en el conjunto de resultados. 
El nuevo documento aparece en la posición `atIndex`. inmediatamente antes 
del documento cuya `_id` es `before`. `before` será `null` si el nuevo documento 
está al final de los resultados. 

{{/better_markdown}}
</dd>

<dt><span class="name">changed(newDocument, oldDocument)
    <span class="or">or</span></span></dt>
<dt><span class="name">changedAt(newDocument, oldDocument, atIndex)</span></dt>
<dd>
{{#better_markdown}}
El contenido de un documento previamente era `oldDocument` y ahora es 
`newDocument`.  La posición del documento cambiado es `atIndex`.
{{/better_markdown}}
</dd>

<dt><span class="name">removed(oldDocument)</span>
  <span class="or">or</span></dt>
<dt><span class="name">removedAt(oldDocument, atIndex)</span></dt>
<dd>
{{#better_markdown}}
El documento `oldDocument` deja de estar en el conjunto de resultados.
Lo que antes era la posición `atIndex`.
{{/better_markdown}}
</dd>

{{#dtdd "movedTo(document, fromIndex, toIndex, before)"}}
Un documento se cambia de posición en el conjunto de resultados, de
 `fromIndex` a `toIndex`
(Que está antes del documento con id  `before`). Sus contenido actual es
`document`.
{{/dtdd}}
</dl>

Utilice `added`, `changed`, y `removed` cuando no le preocupe el orden de 
los documentos en el conjunto de resultados.
when you don't care about the
order of the documents in the result set. Estos son más eficientes que 
`addedAt`, `changedAt`, y `removedAt`.

Antes de `observe` retornos, `added` (o `addedAt`) será llamado cero
o más veces para entregar los primeros resultados de la consulta.

`observe` retorna un manejador de consulta en vivo, que es un objeto con un 
método `stop`.
Llamar `stop` sin argumentos detiene la llamada a las funciones <i>callback</i>  
y desmonta la consulta. **La consulta se ejecutará para siempre hasta que usted 
llame esto.** Si `observe`  se llama desde un cómputo `Deps.autorun`, se detiene 
automáticamente cuando el cómputo se vuelve a ejecutar o esestablecido e detenido.
(Si el cursor se creó con la opción `reactive` establecido en <i>false</i>, 
sólo proporcionará los resultados iniciales y no llama a ningún adicional <i><i>callbacks</i></i>;
no es necesario llamar `stop` en el manejador.)


{{> api_box cursor_observe_changes}}

Establece un *live query* que invoca <i><i>callbacks</i></i> cuando el resultado 
de la consulta cambia.
the query changes. En contraste con [`observe`](#observe),
`observeChanges` que proporciona sólo la diferencia entre el conjunto de 
resultadosthe antiguos y nuevos, no todo el contenido del documento que ha cambiado.

`<i>callbacks</i>` pueden tener la las siguientes funciones como propiedades:


<dl class="<i>callbacks</i>">
<dt><span class="name">added(id, fields)</span>
  <span class="or">or</span></dt>
<dt><span class="name">addedBefore(id, fields, before)</span></dt>
<dd>
{{#better_markdown}}
Un nuevo documento entró en el conjunto de resultados. Tiene
el `id` y `fields` especificados. Contiene todos los campos del
documento excluyendo el campo `_id`. El nuevo documento es anterior al
documento identificado por `before`, o el último si `before` es `null`.
{{/better_markdown}}
</dd>

{{#dtdd "changed(id, fields)"}}
El documento identificado por `id` ha cambiado. `fields` contiene los campos 
modificados con sus nuevos valores. Si un campo se eliminó del documento entonces,
éste estará presente en `fields` con un valor de `undefined`.
{{/dtdd}}

{{#dtdd "movedBefore(id, before)"}}
El documento identificado por `id` ha cambiado su posición en el orden del conjunto 
de resultados, y ahora aparece antes del documento identificado por `before`.
{{/dtdd}}

{{#dtdd "removed(id)"}}
El documento identificado por `id` se eliminó del conjunto de resultados.
{{/dtdd}}
</dl>

`observeChanges` es mucho más eficiente si no se utiliza
`addedBefore` o `movedBefore`.

Antes de que `observeChanges` devuelva, `added` (o `addedBefore`) se llamará
cero o más veces para proporcionar los resultados iniciales de la consulta.

`observeChanges` devuelve un manejador de consulta en vivo, que es un objeto con un
método `stop`.
Llamar `stop` sin argumentos detiene las llamadas de las funciones <i>callback</i> 
y desmonta la consulta. **La consulta se ejecutará para siempre hasta que se llama esto.**
Si `observeChanges` es llamado desde un cómputo `Deps.autorun`,  se detiene 
automáticamente cuando el cómputo se vuelve a ejecutar o es detenido.
(Si el cursor fué creado con la opción `reactive` establecida en <i>false</i>, 
sólo proporcionará los resultados iniciales y no llama a ningún adicional <i><i>callbacks</i></i>;
no es necesario llamar `stop` en el manejador.)

{{#note}}
A diferencia de `observe`, `observeChanges` no proporciona información de la posición 
absoluta. (eso es, la posición `atIndex` en vez de la posición `before`.) Esto es por 
eficiencia.
{{/note}}

Ejemplo:

    //Mantener un seguimiento de cuántos administradores hay online.
    var count = 0;
    var query = Users.find({admin: true, onlineNow: true});
    var handle = query.observeChanges({
      added: function (id, user) {
        count++;
        console.log(user.name + " brings the total to " + count + " admins.");
      },
      removed: function () {
        count--;
        console.log("Lost one. We're now down to " + count + " admins.");
      }
    });

    // Después de cinco segundos, deja de mantener el recuento.
    setTimeout(function () {handle.stop();}, 5000);

{{> api_box collection_object_id}}

`Meteor.Collection.ObjectID` sigue la misma API que el [Node MongoDB driver
`ObjectID`](http://mongodb.github.com/node-mongodb-native/api-bson-generated/objectid.html)
class. Tenga en cuenta que debe utilizar el método `equals`  (o [`EJSON.equals`](#ejson_equals)) para
compararlos; the `===` operator no funcionará. Si va a escribir código genérico que tiene que lidiar 
con campos `_id` que pueden ser cualquier cadena o `ObjectID`s, utilice
[`EJSON.equals`](#ejson_equals) en vez de  `===` para compararlos.

{{#note}}
  Los valores `ObjectID` creados por Meteor no tienen respuestas significativas a su método `getTimestamp`
  ya que actualmente Meteor los construye completamente al azar.
{{/note}}

{{#api_box_inline selectors}}

En su forma más simple, un selector es sólo un conjunto de claves que deben coincidir
en un documento:

    // Coincide con todos los documentos donde eliminado es <i>false</i>
    {deleted: false}

    // Coincide con todos los documentos donde el nombre y apellido son dados.
    {name: "Rhialto", cognomen: "the Marvelous"}

    // Coincide con todos los documentos.
    {}

Pero también puede contener pruebas más complicadas: 

    // Coincide con documentos donde la edad es mayor de 18
    {age: {$gt: 18}}

    // También coincide con documentos donde <i>tags</i> es un <i>array</i> que contiene "popular"
    {tags: "popular"}

    // Coincide con documentos donde fruta es una de tres posibilidades
    {fruit: {$in: ["peach", "plum", "pear"]}}

Ver la [documentación 
 completa](http://www.mongodb.org/display/DOCS/Advanced+Queries).

{{/api_box_inline}}

{{#api_box_inline modifiers}}

 Un modificador es un objeto que describe cómo actualizar un documento 
 en lugar de cambiar algunos de sus campos. 
 Algunos ejemplos:

    // Establece la propiedad 'admin' en el documento a <i>true</i>
    {$set: {admin: true}}

    // Añade 2 a la propiedad 'votes' y añade "Traz"
    // al final del <i>array</i> 'supporters' 
    {$inc: {votes: 2}, $push: {supporters: "Traz"}}

Sin embargo, si un modificador no contiene ningún $-operators, entonces en su lugar 
se interpreta como un documento literal, y reemplaza por completo lo que estaba 
previamente en la base de datos. ( Modificadores literales del documento no están 
actualmente soportados por [validated updates](#allow).)

    // Buscar el documento con id "123", y reemplazarlo completamente.
    Users.update({_id: "123"}, {name: "Alice", friends: ["Bob"]});

Ver la [lista completa de
modificadores](http://www.mongodb.org/display/DOCS/Updating#Updating-ModifierOperations).

{{/api_box_inline}}

{{#api_box_inline sortspecifiers}}

Sorts puede ser specificado usando varias opciones de sintaxis:

    // Todo esto hace la misma cosa thing (ordena en orden ascendente por 
    // la clave  "a", rompiendo lazos en orden descendente de la clave "b")

    [["a", "asc"], ["b", "desc"]]
    ["a", ["b", "desc"]]
    {a: 1, b: -1}

La última forma sólo funcionará si su aplicación JavaScript
conserva el orden de las claves en objetos. 
La mayoría lo hacen, la mayoría de
el tiempo, pero depende de usted para estar seguro. 

{{/api_box_inline}}

{{#api_box_inline fieldspecifiers}}

En el servidor, las consultas pueden especificar una determinado conjunto de campos 
para incluir o excluir del objeto resultado. (El especificador de campo se ignora actualmente en el cliente.)

Para excluir ciertos campos de los objetos resultado, el especificador de campo es un
diccionario cuyas claves son los nombres de campos y cuyos valores son  `0`.

    // Users.find({}, {fields: {password: 0, hash: 0}})

 para devolver un objeto que sólo incluye el campo especificado, utilice `1` 
 como valor. El campo `_id` aún se incluye en el resultado.

    // Users.find({}, {fields: {firstname: 1, lastname: 1}})

No es posible mezclar estilos de inclusión y exclusión.

{{/api_box_inline}}

<h2 id="session"><span>Session</span></h2>

`Session` proporciona un objeto global en el cliente que puede utilizar para
almacenar un conjunto arbitrario de pares clave-valor. Utilícelo para almacenar 
cosas como el elemento actualmente seleccionado en una lista.

¿Qué tiene de especial `Session` es que es reactivo. Si 
llama [`Session.get`](#session_get)`("currentList")`
desde el interior de una plantilla, la plantilla automaticamente se revisualizará
cada vez que se llame [`Session.set`](#session_set)`("currentList", x)`.

{{> api_box set}}

Ejemplo:

    Deps.autorun(function () {
      Meteor.subscribe("chat-history", {room: Session.get("currentRoomId")});
    });

    // Hace que la función pasada a Deps.autorun se reejecute, por lo 
    // que la suscripción de <i>chat-history</i> se mueva a la sala "home".
    Session.set("currentRoomId", "home");

{{> api_box setDefault}}

Esto es útil en el código de inicialización, para evitar volver a inicializar una
variable de sesión cada vez que una nueva versión de su aplicación se cargue.

{{> api_box get}}

Ejemplo:

    Session.set("enemy", "Eastasia");
    var frag = Meteor.render(function () {
      return "<p>We've always been at war with " +
        Session.get("enemy") + "</p>";
    });

    // Page will say "We've always been at war with Eastasia"
    document.body.append(frag);

    // Page will change to say "We've always been at war with Eurasia"
    Session.set("enemy", "Eurasia");

{{> api_box equals}}

Si el valor es un escalar, entonces estas dos expresiones hacen la misma cosa: 

    (1) Session.get("key") === value
    (2) Session.equals("key", value)

... pero el segundo es siempre mejor. Se dispara el menor número de invalidaciones
(Se vuelve a dibujar la plantilla), haciendo su programa más eficiente.

Ejemplo:

    <template name="postsView">
    {{dstache}}! Muestra la actualización dinámica de una lista de elementos. 
     {{! Deje que el usuario haga clic en un elemento para seleccionarlo.
         Al elemento seleccionado se le da una clase CSS para que 
         pueda ser mostrado de manera diferente. }}

    {{dstache}}#each posts}}
      {{dstache}}> postItem }}
    {{dstache}}/each}}
    </{{! }}template>

    <template name="postItem">
      <div class="{{dstache}}postClass}}">{{dstache}}title}}</div>
    </{{! }}template>

    ///// in JS file
    Template.postsView.posts = function() {
      return Posts.find();
    };

    Template.postItem.postClass = function() {
      return Session.equals("selectedPost", this._id) ?
        "selected" : "";
    };

    Template.postItem.events({
      'click': function() {
        Session.set("selectedPost", this._id);
      }
    });

    // El uso de Session.equals aquí significa que cuando el usuario clica
    // en un item y cambia la selección, sólo los <i>items</i> recién seleccionado
    // y el recién desseleccionado son re-visualizados.
    //
    // Si Session.get había sido utilizado en lugar de Session.equals, entonces
    // cuando la selección cambia, todos los items serán revisualizados.

Para los valores de sesión de object y array, no puede utilizar `Session.equals`; en su lugar,
usted necesita utilizar el paquete `underscore` y escribir
`_.isEqual(Session.get(key), value)`.



<h2 id="accounts_api"><span>Accounts</span></h2>
 
El sistema <i>Meteor Accounts</i> construye en la parte superior de `userId` soporte a 
[`publish`](#publish_userId) y [`methods`](#method_userId). Los paquetes principales 
añaden el concepto de documentos usuario almacenado en la base de datos, y
paquetes adicionales añaden [secure password
authentication](#accounts_passwords), [integration with third party
login services](#meteor_loginwithexternalservice), y un [pre-built user
interface](#accountsui).

El básico <i>Accounts system</i> está en el paquete `accounts-base`, pero
las aplicaciones suelen incluir esto automaticamente mediante la adición de uno de los
paquetes proveedores de <i>login</i>: `accounts-password`, `accounts-facebook`,
`accounts-github`, `accounts-google`, `accounts-meetup`,
`accounts-twitter`, or `accounts-weibo`.


{{> api_box user}}

Recupera el registro de usuario para el desde
la colección [`Meteor.users`](#meteor_users).

On the client, this will be the subset of the fields in the document that
are published from the server (other fields won't be available on the
client). By default the server publishes `username`, `emails`, and
`profile`. Ver [`Meteor.users`](#meteor_users) for more on
the fields used in user documents.

{{> api_box userId}}

{{> api_box users}}

Esta colección contiene un documento por usuario registrado. Aquí hay un ejemplo:
documento de usuario:

    {
      _id: "bbca5d6a-2156-41c4-89da-0329e8c99a4f",  // Meteor.userId()
      username: "cool_kid_13", // unique name
      emails: [
        // cada dirección de correo electrónico sólo puede pertenecer a un usuario
        { address: "cool@Ejemplo.com", verified: true },
        { address: "another@different.com", verified: false }
      ],
      createdAt: 1349761684042,
      profile: {
        //  El perfil puede ser escrito por el usuario de forma predeterminada.
        name: "Joe Schmoe"
      },
      services: {
        facebook: {
          id: "709050", // facebook id
          accessToken: "AAACCgdX7G2...AbV9AZDZD"
        },
        resume: {
          loginTokens: [
            { token: "97e8c205-c7e4-47c9-9bea-8e2ccc0694cd",
              when: 1349761684048 }
          ]
        }
      }
    }

Un documento de usuario puede contener cualquier dato que desee guardar sobre un usuario.
Meteor trata los siguientes campos especialmente:

- `username`: un único <i>String</i> que identifica el usuario.
- `emails`: un <i>Array</i> de <i>Objects</i> con claves `address` y `verified`;
  una dirección <i>email</i> puede pertenecer a más de un usuario.  `verified` es
  un <i>Boolean</i> que es <i>true</i> si el usuario ha [verified the
  address](#accounts_verifyemail) con una señal enviada a través de correo electrónico.
- `createdAt`: un <i>timestamp</i> numérico (milliseconds since January 1 1970)
   of el momento en que el usuario  ha creado el documento.
- `profile`: un <i>Object</i> que (por defecto) el usuario puede crear
  y actualizar con los datos.
- `services`: un <i>Object</i> ue contiene los datos utilizados por los servicios de login 
  en particular. Por Ejemplo, su campo `reset` contiene
  fichas utilizadas por enlaces [forgot password](#accounts_forgotpassword),
  y su campo `resume` contiene fichas utilizadas mantenerle 
  conectado entre sesiones.

Igual que todas las colecciones [Meteor.Collection](#collections)s, usted puede acceder a todos 
los documentos en el servidor, pero sólo aquellos específicamente publicada por el servidor
están accesibles en el cliente.

Por defecto, el usuario actual `username`, `emails` y `profile` 
se publican en el cliente. Puede publicar campos adicionales para el
 usuario actual con:

    Meteor.publish("userData", function () {
      return Meteor.users.find({_id: this.userId},
                               {fields: {'other': 1, 'things': 1}});
    });

Si el paquete `autopublish` está instalado, los campos `username` y `profile`
de todos los usuarios se publican para todos los clientes. Para publicar campos 
específicos de todos los usuarios:

    Meteor.publish("allUserData", function () {
      return Meteor.users.find({}, {fields: {'nested.things': 1}});
    });

A los suarios, por defecto se les permite especificar su propio campo `profile` con
[`Accounts.createUser`](#accounts_createuser) y  modificarlo con
`Meteor.users.update`. Para permitir a los usuarios editar campos adicionales, utilice
[`Meteor.users.allow`](#allow). Para prohibir a los usuarios que realicen cualquier modificación
en su documento de usuario :

    Meteor.users.deny({update: function () { return true; }});


{{> api_box loggingIn}}

Por Ejemplo, [the `accounts-ui` package](#accountsui) utiliza esta opción para mostrar una
animación mientras que la solicitud de acceso se está procesando.

{{> api_box logout}}

{{> api_box loginWithPassword}}

Esta función está proporcionada por el paquete `accounts-password`. Ver el
[Passwords](#accounts_passwords) en la sección debajo.


{{> api_box loginWithExternalService}}

Estas funciones inician el proceso de <i>login</i> con un servicio externo
(ej: Facebook, Google, etc), utilizando<i> OAuth</i>. Cuándo se invocan abren una nueva ventana pop-up
que carga la página de <i>login</i> del proveedor. Una vez que el usuario ha iniciado la sesión 
con el proveedor, la ventana pop-up se cierra y el cliente Meteor se inicia en el servidor Meteor
con información proporcionada por el servicio externo.

<a id="requestpermissions" name="requestpermissions" />

Además de identificar al usuario en su aplicación, algunos servicios 
tienen APIs que le permiten actuar en nombre del usuario. Para 
solicitar permisos específicos del usuario, pase la opción 
`requestPermissions` a la funcción <i>login</i>. Esto causará que el usuario
sea presentado con una página adicional en el <i>pop-up</i> dialogo para permitir
el acceso a sus datos. El usuario `accessToken` &mdash; con permisos
de acceso a los servicios API &mdash; es guardado en el campo `services` del
documento del usuario. Los valores admitidos por `requestPermissions` son diferentes
para cada servicio de <i>login</i> y y están documentados sus respectivos sitios para 
desarrolladores:

- Facebook: <http://developers.facebook.com/docs/authentication/permissions/>
- GitHub: <http://developer.github.com/v3/oauth/#scopes>
- Google: <https://developers.google.com/accounts/docs/OAuth2Login#scopeparameter>
- Meetup: <http://www.meetup.com/meetup_api/auth/#oauth2-scopes>
- Twitter, Weibo: `requestPermissions` actualmente no suportado

Los servicios de acceso externos suelen requerir registro y configuración
en su aplicación antes del uso.  La manera más fácil de hacerlo es con el
[`accounts-ui` package](#accountsui) que presenta una guía paso a paso
al configurar cada servicio. Sin embargo, los datos pueden también ser introducidos
manualmente en la colección `Accounts.loginServiceConfiguration`. 

Por Ejemplo:

    // Primero, borre la configuración de entrada en el caso de que el servicio ya esté configurado
    Accounts.loginServiceConfiguration.remove({
      service: "weibo"
    });
    Accounts.loginServiceConfiguration.insert({
      service: "weibo",
      clientId: "1292962797",
      secret: "75a730b58f5691de5522789070c319bc"
    });


Cada servicio externo tiene su propio paquete de proveedor de <i>login</i> y función de <i>login</i>
Por ejemplo, para respaldar el <i>login GitHub</i>, ejecute `$ meteor add accounts-github` y utilice la
función `Meteor.loginWithGithub` :

    Meteor.loginWithGithub({
      requestPermissions: ['user', 'public_repo']
    }, function (err) {
      if (err)
        Session.set('errorMessage', err.reason || 'Unknown error');
    });



{{> api_box currentUser}}
{{> api_box loggingInTemplate}}
{{> api_box accounts_config}}
{{> api_box accounts_ui_config}}

Ejemplo:

    Accounts.ui.config({
      requestPermissions: {
        facebook: ['user_likes'],
        github: ['user', 'repo']
      },
      requestOfflineToken: {
        google: true
      },
      passwordSignupFields: 'USERNAME_AND_OPTIONAL_EMAIL'
    });

{{> api_box accounts_validateNewUser}}

Esto puede ser llamado multiple veces. Si alguna de las funciones devuelve `false` o
lanza un error, la creación de nuevo usuario se interrumpe. Para establecer un específico 
mensage de error (que será visualizado por [`accounts-ui`](#accountsui)), al lanzar un nuevo
[`Meteor.Error`](#meteor_error).

Ejemplo:

    // Validar nombre de usuario, envía un mensaje de error específico en caso de fallo.
    Accounts.validateNewUser(function (user) {
      if (user.username && user.username.length >= 3)
        return true;
      throw new Meteor.Error(403, "Username must have at least 3 characters");
    });
    // Valida nombre de usuario, sin un mensaje de error específico.
    Accounts.validateNewUser(function (user) {
      return user.username !== "root";
    });

{{> api_box accounts_onCreateUser}}

Utilice esta opción cuando necesite hacer algo más que simplemente aceptar o rechazar 
la creación del nuevo usuario. Con esta función puede controlar mediante programación 
el contenido del nuevo documento de usuario.

La función que pase será llamada con dos argumentos: `options` y `user`. El argumento `options` viene
de [`Accounts.createUser`](#accounts_createuser) para usuarios basados ​​en contraseñas o de un flujo 
de servicio de acceso externo. `options` puede provenir de un cliente no confiable así que asegúrese 
de validar cualquier valor que lea de la misma.

El argumento `user` se crea en el servidor y contiene un propuesto objeto usuario
con todos los campos generados automáticamente requeridos por el usuario para iniciar sesión.

La función debe devolver el documento de usuario (ya sea de uno pasado o a
un objeto recién creado) con cualquier modificación que se desee. El documento devuelto
se inserta directamente en la colección [`Meteor.users`](#meteor_users).

La función para crear usuario por defecto simplemene copia `options.profile` en
el nuevo documento de usuario. Llamando `` onCreateUser reemplaza el enganche por defecto.
Esto sólo puede ser llamado una vez.

Ejemplo:

<!-- XXX replace d6 with _.random once we have underscore 1.4.2 -->

    // Support for playing D&D: Roll 3d6 for dexterity
    Accounts.onCreateUser(function(options, user) {
      var d6 = function () { return Math.floor(Random.fraction() * 6) + 1; };
      user.dexterity = d6() + d6() + d6();
      // We still want the default hook's 'profile' behavior.
      if (options.profile)
        user.profile = options.profile;
      return user;
    });


<h2 id="accounts_passwords"><span>Passwords</span></h2>

El paquete  `accounts-password` contiene un sistema completo para autenticación basado en contraseña.
Además del proceso básico Nombre de usuario e inicio de sesión basado en contraseña, también soporta
inicio de sesión basado en email incluyendo verificación de direcciones y recuperación de contraeña 
por <i>email</i>.

A diferencia de la mayoría de  web applications, aplicaciones web, el cliente Meteor no envía 
la contraseña del usuario directamente al servidor. Se utiliza el [Secure Remote Password
protocol](http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol)
para garantizar que el servidor nunca ve la contraseña del usuario en texto plano. Esto
ayuda a proteger contra fugas embarazosas de contraseñas si la base de datos del servidor
se ve comprometida.

Para agregar soporte de password a su aplicación, ejecute `$ meteor add
accounts-password`. Usted puede construir su propio interfaz de usuario utilizando
las funciones de abajo, o utilizar el [`accounts-ui` package](#accountsui) para
incluir una llave en la interfaz de usuario para un registro basado en contraseña.


{{> api_box accounts_createUser}}

Esta función inicia la sesión como el nuevo usuario creado  que
a finalizdo con éxito. En el servidor, devuelve el <i>id</i> del nuevo usuario creado.

En el cliente, debe pasar  `password` y un `username` o `email`
&mdash; información suficiente para que el usuario pueda acceder de nuevo más 
tarde. En el servidor, puede pasar cualquier subconjunto de estas opciones, pero el
usuario no será capaz de iniciar sesión hasta que tenga un identificador y una contraseña.

Para crear una cuenta sin contraseña en el servidor y todavía permitir al
usuario elegir su propia contraseña, llame `createUser` con la opción `email` 
y luego llame [`Accounts.sendEnrollmentEmail`](#accounts_sendenrollmentemail). Esto
enviará al usuario un correo electrónico con un enlace para establecer su contraseña inicial.

Por defecto la opción `profile`  se añade directamente al nuevo documento de usuario. Para
invalidar este comportamiento utilice [`Accounts.onCreateUser`](#accounts_oncreateuser).

Esta función sólo se utiliza para crear usuarios con contraseñas. 


{{> api_box accounts_changePassword}}

{{> api_box accounts_forgotPassword}}

Esto desencadena una llamada a [`Accounts.sendResetPasswordEmail`](#accounts_sendresetpasswordemail)
en el servidor. Pasa el testigo que el usuario recibirá en este correo electrónico 
a [`Accounts.resetPassword`](#accounts_resetpassword) para completar el proceso de restablecimiento 
de contraseña.

Si está utilizando el [`accounts-ui` package](#accountsui), esto se maneja de forma automática.
automatically. De lo contrario, es su responsibilidad solicitar al usuario la 
nueva contraseña y llame `resetPassword`.

{{> api_box accounts_resetPassword}}

Esta función acepta <i>tokens</i> generadas 
por [`Accounts.sendResetPasswordEmail`](#accounts_sendresetpasswordemail)
y
[`Accounts.sendEnrollmentEmail`](#accounts_sendenrollmentemail).

{{> api_box accounts_setPassword}}

{{> api_box accounts_verifyEmail}}

Esta función acepta <i>tokens</i> generadas 
por [`Accounts.sendVerificationEmail`](#accounts_sendverificationemail). Lo
establece en el campo `emails.verified` en el registro de usuario.

{{> api_box accounts_sendResetPasswordEmail}}

El <i>token</i> en este email debe ser pasado
a [`Accounts.resetPassword`](#accounts_resetpassword).

Para personalizar el contenido del correo electrónico, Ver
[`Accounts.emailTemplates`](#accounts_emailtemplates).

{{> api_box accounts_sendEnrollmentEmail}}

El <i>token</i> en este email debe ser pasado
a [`Accounts.resetPassword`](#accounts_resetpassword).

Para personalizar el contenido del correo electrónico, Ver
[`Accounts.emailTemplates`](#accounts_emailtemplates).

{{> api_box accounts_sendVerificationEmail}}

El <i>token</i> en este email debe ser pasado
a [`Accounts.verifyEmail`](#accounts_verifyemail).

Para personalizar el contenido del correo electrónico, Ver
[`Accounts.emailTemplates`](#accounts_emailtemplates).

{{> api_box accounts_emailTemplates}}

Este es un `Object` con varios campos se utilizan para generar texto 
para los <i>emails</i> enviados por `sendResetPasswordEmail`, `sendEnrollmentEmail`,
y `sendVerificationEmail`.

Reemplazar los campos del objeto asignandolos:

- `from`: Un `String` con un [RFC5322](http://tools.ietf.org/html/rfc5322) Dirección del 
   remitente. Por defecto, el <i>email</i> se envía desde `no-reply@meteor.com`. Si usted 
   desea recibir <i>email</i> de los usuarios que solicitan ayuda con su cuenta,
    asegúrese de establecer este a una dirección de <i>email</i> en el que puede recibir correos.
- `siteName`: el nombre público de su aplicación. El valor predeterminado es el nombre DNS de
   la aplicación (eg: `awesome.meteor.com`).
- `resetPassword`: Un `Object` con dos campos:
 - `resetPassword.subject`: Una `Function` que toma un objeto usuario y returna
   un `String` para la línea de asunto de un restablecimiento <i>email</i> de contraseña.
 - `resetPassword.text`: Una `Function` que toma un objeto usuario y una <i>url</i>, y
   devuelve el cuerpo de texto para restablecer el <i>password</i> por <i>email</i>.
- `enrollAccount`: Igual que `resetPassword`, pero para contraseña inicial al configurar 
   nuevas cuentas.
- `verifyEmail`: Igual que `resetPassword`, pero para verificar la dirección de correo 
electrónico del usuario.


Ejemplo:

    Accounts.emailTemplates.siteName = "AwesomeSite";
    Accounts.emailTemplates.from = "AwesomeSite Admin <accounts@Ejemplo.com>";
    Accounts.emailTemplates.enrollAccount.subject = function (user) {
        return "Welcome to Awesome Town, " + user.profile.name;
    };
    Accounts.emailTemplates.enrollAccount.text = function (user, url) {
       return "You have been selected to participate in building a better future!"
         + " To activate your account, simply click the link below:\n\n"
         + url;
    };


<h2 id="templates_api"><span>Templates</span></h2>

Una plantilla que se declara como `<{{! }}template name="foo"> ... </{{!
}}template>` Puede ser accedida como la función `Template.foo`, que
devuelve una cadena de HTML cuando es llamada.

La misma plantilla puede ocurrir muchas veces en la página, y
estos sucesos se denominan instancias de plantilla.  Las Instancias de la plantilla tienen un
ciclo de vida de creación, colocada el documento, extraida del documento y destruida.
Meteor gestiona estas etapas por usted, incluyendo la determinación de cuando una instancia de 
plantilla ha sido eliminado o sustituido y debe ser limpiada
Usted puede asociar datos a una instancia de plantilla,
template instance, y se puede acceder a los nodos DOM cuando se encuentra en el documento.

Además, Meteor mantendrá una instancia de plantilla y su estado
incluso si su código HTML circundante se vuelve a representar en los nuevos nodos DOM.
even if its surrounding HTML is re-rendered into new DOM nodes.  
Como siempre  la estructura de invocaciones de plantilla es la misma,
Meteor no tendrá en cuenta todas las instancias que han sido creadas o destruidas.
Puede solicitar que los mismos nodos DOM deban conservarse,
utilizando `preserve` y `constant`.

Hay una serie de <i><i>callbacks</i></i> y directivas que puede especificar en 
una plantilla nombrada y que se aplique en todas las instancias 
de la plantilla.
Se describen a continuación. 

{{> api_box template_call}}

Cuando se llama el interior de un auxiliar de plantilla, el cuerpo de `Meteor.render`,
u otros lugares donde HTML reactivo se está generando, el HTML que resulta
es anotado para que sea visualizado como elementos DOM reactivos.
De lo contrario, el HTML es sobrio y estático.

{{> api_box template_rendered}}

Este <i>callback</i> se llama una vez cuando una instancia de <i>Template</i>.*myTemplate* es
mostrada en nodos DOM y lo pone en el documento por primera vez, 
y de nuevo cada vez que cualquier parte de la plantilla es revisualizada.


En el cuerpo del <i>callback</i>, `this` es un objeto [template
instance](#template_inst) quew es único en esta ocurrencia de
la plantilla y persiste a través de revisualizaciones. Utilize los <i><i>callbacks</i></i> 
`created` y `destroyed` para realizar inicialización o limpieza en el objeto.

{{> api_box template_created}}

Este <i>callback</i> es llamado cuando una invocación de *myTemplate* representa
una nueva ocurrencia de la plantilla y no una representación de una exitente 
instancia de plantilla.  Dentro del <i>callback</i> , `this` es el nuevo objeto [template
instance](#template_inst). Las propiedades que usted puede establecer en este objeto
será visible desde los <i>callbacks</i>  `rendered` y `destroyed` y desde 
los manipuladores de eventos.

Este <i>callback</i> se dispara una vez y es el primer <i>callback</i> que se dispara. Cada
`created` tiene un correspondiente `destroyed`; es decir, si se obtiene un
<i>callback</i> `created` con un cierto object de instancia de plantilla en `this`,
usted eventualmente obtendrá un <i>callback</i> `destroyed` para el mismo objeto.

{{> api_box template_destroyed}}

This <i>callback</i> es llamado cuando una occurrencia de una plantilla es sacado fuera de
la página por cualquier motivo y no se sustituye con una nueva re-representación.  Dentro 
del <i>callback</i>, `this` es el objeto [template instance](#template_inst) que será 
destruido.

Este <i>callback</i> es más útil para limpiar o deshacer los efectos externos de
`created`.  Se dispara una vez y es el último <i>callback</i> en ser disparado.


{{> api_box template_events}}

Declarar controladores de eventos para las instancias de esta plantilla.
Multiple llamadas añaden nuevos controladores de eventos sumandolos
a los existentes.

Ver [Event Maps](#eventmaps) para una descripción detallada del formato de mapa eventos
y de cómo la gestión de eventos trabaja en Meteor.

{{> api_box template_helpers}}

Cada plantilla tiene un diccionario local de auxiliares que están disponibles en la misma,
y esta llamada especifica auxiliares para añadir al dictionario de plantillas.

Ejemplo:

    Template.myTemplate.helpers({
      foo: function () {
        return Session.get("foo");
      }
    });

En <i>Handlebars</i>, este auxiliar se invoca como `{{dstache}}foo}}`.

La siguiente sintaxis es equivalente pero no funciona para las propiedades reservadas 
de nombres:

    Template.myTemplate.foo = function () {
      return Session.get("foo");
    };

{{> api_box template_preserve}}

Usted puede "preservar" un elemento DOM  durante la re-representación, dejando el
elemento existente en el lugar del documento mientras se sustituye el código HTML 
circundante.
Esto significa que una re-representación de plantilla no tiene por qué
estorbar los campos de texto, <i>iframes</i>, y otros elementos sensitivos 
que contenga.  Los elementos a preservar deben estar presentes tanto como nodos en
el viejo DOM y como <i>tags</i> en el nuevo HTML.  Meteor parcheará el DOM
basándose en los elementos conservados.

{{#note}}
Pot defecto, las nuevas <i>apps</i> Meteor automaticamente incluyen el
paquete `preserve-inputs`.  Todos estos elementos preservados de tipo
`input`, `textarea`, `button`, `select`, y `option` que tienen un único atributo
`id` o que tienen atributos `name` únicos dentro de un 
un elemento que lo encierra con un atributo `id`.  Para desactivar 
este comportamiento por defecto,
behavior, simplemente borre el paquete `preserve-inputs`.
{{/note}}

Preservar es útil en varietad de casos en los que reemplazar un elemento DOM
con un idéntico o elemento modificado no tendría el mismo efecto 
que retener el elemento original.  Estos incluyen:

* Campos <i>Input text</i> y otros controles de formulario
* Elementos con animaciones CSS
* Iframes
* Nodos con referencias que se encuentran en el código JavaScript

Si desea preservar una región completa del DOM, un element y sus 
hijos, o nodos no representados por Meteor, utilice en su lugar un [constant
region](#constant).

Para preservar nodos, pase una lista de selectores, cada una de ellas debe coincidir
por lo menos con un elemento en la plantilla.  Cuando la plantilla es re-visualizada,
el selector es ejecutado en el viejo DOM y el nuevo DOM, y Meteor reutilizará
el viejo elemento en su lugar mientras se trabajan cambios en todo el código HTML.

Una segunda forma de `preserve` toma una función de etiquetado para cada selector
y permite que los selectores coincidan con varios nodos. La función etiquetado de nodos
toma un nodo y retorna una caden etiqueta que es única para cada nodo
o `false` para excluir el nodo de ser preservado.

Por Ejemplo, para preservar todos los elementos <code>`<input>`</code>  
con <i>ids</i> la plantilla 'foo', utilice:

    Template.foo.preserve({
      'input[id]': function (node) { return node.id; }
    });

Los selectores son interpretados como <i>rooted</i> de nivel superior de la plantilla.
Cada ocurrencia de la plantilla funciona de forma independiente, por lo que los selectores
no tiene que ser únicos en toda la página, sólo dentro de una ocurrencia de la plantilla.
of the template. Los selectores coincidirán con los nodos, incluso si están en
sub-plantillas.

Preservar un nodo *no* preserva sus atributos o contenidos. Ellos 
se actualizarán para reflejar el nuevo HTML. El texto en campos <i>input</i> no es 
preservado a menos que el campo <i>input</i> tenga el foco, en tal caso el cursor y
la seleción se dejant intactos. <i>Iframes</i> retienen su estado de navegació y
las animaciones continuarán funcionando siempre y cuando sus parámetros no hayan cambiado.

Hay algunos casos en los que los nodos no pueden ser preservados debido a
las limitaciones inherentes a la API DOM. Por Ejemplo, un <i>tag name</i> de elemento 
no puede ser cambiado, y no puede ser movido en relación a sus padres o otros nodos
preservados. Por esta razón, los nodos que están  re-ordenados o 
re-emparentados por una actualización no serán preservados.

{{#note}}
Las versiones anteriores de Meteor tenían un implícito <i>page-wide</i> `preserve`
Esta directiva que etiquetaba nodos por sus atributos "id" y "name".
Ha sido eliminado en favor del mecanismo explícito <i>opt-in</i>.
{{/note}}


<h2 id="template_inst"><span>Template instances</span></h2>

A template instance object represents an occurrence of a template in
the document.  It can be used to access the DOM and it can be
assigned properties that persist across page re-renderings.

Template instance objects are found as the value of `this` in the
`created`, `rendered`, and `destroyed` template <i>callbacks</i> and as an
argument to event handlers.

In addition to the properties and functions described below, you can
assign additional properties of your choice to the object.  Property names
starting with `_` are guaranteed to be available for your use.  Use
the `created` and `destroyed` <i>callbacks</i> to perform initialization or
clean-up on the object.

You can only access `findAll`, `find`, `firstNode`, and `lastNode`
from the `rendered` <i>callback</i> and event handlers, not from `created`
and `destroyed`, because they require the template instance to be
in the DOM.

{{> api_box template_findAll}}

Returns an array of DOM elements matching `selector`.

The template instance serves as the document root for the selector. Only
elements inside the template and its sub-templates can match parts of
the selector.

{{> api_box template_find}}

Returns one DOM element matching `selector`, or `null` if there are no
such elements.

The template instance serves as the document root for the selector. Only
elements inside the template and its sub-templates can match parts of
the selector.

{{> api_box template_firstNode}}

The two nodes `firstNode` and `lastNode` indicate the extent of the
rendered template in the DOM.  The rendered template includes these
nodes, their intervening siblings, and their descendents.  These two
nodes are siblings (they have the same parent), and `lastNode` comes
after `firstNode`, or else they are the same node.

{{> api_box template_lastNode}}

{{> api_box template_data}}

This property provides access to the data context at the top level of
the template.  It is updated each time the template is re-rendered.
Access is read-only and non-reactive.


{{> api_box render}}

`Meteor.render` creates a `DocumentFragment` (a sequence of DOM nodes)
that automatically updates in realtime. Most Meteor apps don't need to
call this directly; they use templates and Meteor handles the rendering.

Pass in `htmlFunc`, a function that returns an HTML
string. `Meteor.render` calls the function and turns the output into
DOM nodes. Meanwhile, it tracks the data that was used when `htmlFunc`
ran, and automatically wires up <i>callbacks</i> so that whenever any of the
data changes, `htmlFunc` is re-run and the DOM nodes are updated in
place.

You may insert the returned `DocumentFragment` directly into the DOM
wherever you would like it to appear. The inserted nodes will continue
to update until they are taken off the screen. Then they will be
automatically cleaned up. For more details about clean-up, Ver
[`Deps.flush`](#deps_flush).

`Meteor.render` tracks the data dependencies of `htmlFunc` by running
it in a reactive computation, so it can respond to changes in any reactive
data sources used by that function. For more information, or to learn
how to make your own reactive data sources, Ver
[Reactivity](#reactivity).

Ejemplo:

    // Client side: show the number of players online.
    var frag = Meteor.render(function () {
      return "<p>There are " + Players.find({online: true}).count() +
        " players online.</p>";
    });
    document.body.appendChild(frag);

    // Server side: find all players that have been idle for a while,
    // and mark them as offline. The count on the screen will
    // automatically update on all clients.
    Players.update({idleTime: {$gt: 30}}, {$set: {online: false}});

{{> api_box renderList}}

Creates a `DocumentFragment` that automatically updates as the results
of a database query change. Most Meteor apps use `{{dstache}}#each}}` in
a template instead of calling this directly.

`renderList` is more efficient than using `Meteor.render` to render HTML
for a list of documents.  For Ejemplo, if a new document is created in
the database that matches the query, a new item will be rendered and
inserted at the appropriate place in the DOM without re-rendering the
other elements.  Similarly, if a document changes position in a sorted
query, the DOM nodes will simply be moved and not re-rendered.

`docFunc` is called as needed to generate HTML for each document.  If
you provide `elseFunc`, then whenever the query returns no results, it
will be called to render alternate content. You might use this to show
a message like "No records match your query."

Each call to `docFunc` or `elseFunc` is run in its own reactive
computation so that if it has other external data dependencies, it will be
individually re-run when the data changes.

Ejemplo:

    // List the titles of all of the posts that have the tag
    // "frontpage". Keep the list updated as new posts are made, as tags
    // change, etc.  Display the selected post differently.
    var frag = Meteor.renderList(
      Posts.find({tags: "frontpage"}),
      function(post) {
        var style = Session.equals("selectedId", post._id) ? "selected" : "";
        // A real app would need to quote/sanitize post.name
        return '<div class="' + style + '">' + post.name + '</div>';
      });
    document.body.appendChild(frag);

    // Select a post.  This will cause only the selected item and the
    // previously selected item to update.
    var somePost = Posts.findOne({tags: "frontpage"});
    Session.set("selectedId", somePost._id);


{{#api_box_inline eventmaps}}

Several functions take event maps. An event map is an object where
the properties specify a set of events to handle, and the values are
the handlers for those events. The property can be in one of several
forms:

<dl>
{{#dtdd "<em>eventtype</em>"}}
Matches a particular type of event, such as 'click'.
{{/dtdd}}

{{#dtdd "<em>eventtype selector</em>"}}
Matches a particular type of event, but only when it appears on
an element that matches a certain CSS selector.
{{/dtdd}}

{{#dtdd "<em>event1, event2</em>"}}
To handle more than one type of event with the same function, use a
comma-separated list.
{{/dtdd}}
</dl>

The handler function receives two arguments: `event`, an object with
information about the event, and `template`, a [template
instance](#template_inst) for the template where the handler is
defined.  The handler also receives some additional context data in
`this`, depending on the context of the current element handling the
event.  In a Handlebars template, an element's context is the
Handlebars data context where that element occurs, which is set by
block helpers such as `#with` and `#each`.

Ejemplo:

    {
      // Fires when any element is clicked
      'click': function (event) { ... },

      // Fires when any element with the 'accept' class is clicked
      'click .accept': function (event) { ... },

      // Fires when 'accept' is clicked, or a key is pressed
      'keydown, click .accept': function (event) { ... }
    }

Most events bubble up the document tree from their originating
element.  For Ejemplo, `'click p'` catches a click anywhere in a
paragraph, even if the click originated on a link, span, or some other
element inside the paragraph.  The originating element of the event
is available as the `target` property, while the element that matched
the selector and is currently handling it is called `currentTarget`.

    {
      'click p': function (event) {
        var paragraph = event.currentTarget; // always a P
        var clickedElement = event.target; // could be the P or a child element
      }
    }

If a selector matches multiple elements that an event bubbles to, it
will be called multiple times, for Ejemplo in the case of `'click
div'` or `'click *'`.  If no selector is given, the handler
will only be called once, on the original target element.

The following properties and methods are available on the event object
passed to handlers:

<dl class="objdesc">
{{#dtdd name="type" type="String"}}
The event's type, such as "click", "blur" or "keypress".
{{/dtdd}}

{{#dtdd name="target" type="DOM Element"}}
The element that originated the event.
{{/dtdd}}

{{#dtdd name="currentTarget" type="DOM Element"}}
The element currently handling the event.  This is the element that
matched the selector in the event map.  For events that bubble, it may
be `target` or an ancestor of `target`, and its value changes as the
event bubbles.
{{/dtdd}}

{{#dtdd name="which" type="Number"}}
For mouse events, the number of the mouse button (1=left, 2=middle, 3=right).
For key events, a character or key code.
{{/dtdd}}

{{#dtdd "stopPropagation()"}}
Prevent the event from propagating (bubbling) up to other elements.
Other event handlers matching the same element are still fired, in
this and other event maps.
{{/dtdd}}

{{#dtdd "stopImmediatePropagation()"}}
Prevent all additional event handlers from being run on this event,
including other handlers in this event map, handlers reached by
bubbling, and handlers in other event maps.
{{/dtdd}}

{{#dtdd "preventDefault()"}}
Prevents the action the browser would normally take in response to this
event, such as following a link or submitting a form.  Further handlers
are still called, but cannot reverse the effect.
{{/dtdd}}

{{#dtdd "isPropagationStopped()"}}
Returns whether `stopPropagation()` has been called for this event.
{{/dtdd}}

{{#dtdd "isImmediatePropagationStopped()"}}
Returns whether `stopImmediatePropagation()` has been called for this event.
{{/dtdd}}

{{#dtdd "isDefaultPrevented()"}}
Returns whether `preventDefault()` has been called for this event.
{{/dtdd}}
</dl>

Returning `false` from a handler is the same as calling
both `stopImmediatePropagation` and `preventDefault` on the event.

Event types and their uses include:

<dl class="objdesc">
{{#dtdd "<code>click</code>"}}
Mouse click on any element, including a link, button, form control, or div.
Use `preventDefault()` to prevent a clicked link from being followed.
Some ways of activating an element from the keyboard also fire `click`.
{{/dtdd}}

{{#dtdd "<code>dblclick</code>"}}
Double-click.
{{/dtdd}}

{{#dtdd "<code>focus, blur</code>"}}
A text input field or other form control gains or loses focus.  You
can make any element focusable by giving it a `tabindex` property.
Browsers differ on whether links, checkboxes, and radio buttons are
natively focusable.  These events do not bubble.
{{/dtdd}}

{{#dtdd "<code>change</code>"}}
A checkbox or radio button changes state.  For text fields, use
`blur` or key events to respond to changes.
{{/dtdd}}

{{#dtdd "<code>mouVernter, mouseleave</code>"}} The pointer enters or
leaves the bounds of an element.  These events do not bubble.
{{/dtdd}}

{{#dtdd "<code>mousedown, mouseup</code>"}}
The mouse button is newly down or up.
{{/dtdd}}

{{#dtdd "<code>keydown, keypress, keyup</code>"}}
The user presses a keyboard key.  `keypress` is most useful for
catching typing in text fields, while `keydown` and `keyup` can be
used for arrow keys or modifier keys.
{{/dtdd}}
</dl>

Other DOM events are available as well, but for the events above,
Meteor has taken some care to ensure that they work uniformly in all
browsers.

{{/api_box_inline}}



{{#api_box_inline constant}}

You can mark a region of a template as "constant" and not subject to
re-rendering using the
`{{dstache}}#constant}}...{{dstache}}/constant}}` block helper.
Content inside the `#constant` block helper is preserved exactly as-is
even if the enclosing template is re-rendered.  Changes to other parts
of the template are patched in around it in the same manner as
`preserve`.  Unlike individual node preservation, a constant region
retains not only the identities of its nodes but also their attributes
and contents.  The contents of the block will only be evaluated once
per occurrence of the enclosing template.

Constant regions allow non-Meteor content to be embedded in a Meteor
template.  Many third-party widgets create and manage their own DOM
nodes programmatically. Typically, you put an empty element in your
template, which the widget or library will then populate with
children. Normally, when Meteor re-renders the enclosing template it
would remove the new children, since the template says it should be
empty. If the container is wrapped in a `#constant` block, however, it
is left alone; whatever content is currently in the DOM remains.

{{#note}}
Constant regions are intended for embedding non-Meteor content.
Event handlers and reactive dependencies don't currently work
correctly inside constant regions.
{{/note}}


{{/api_box_inline}}

{{#api_box_inline isolate}}

Each template runs as its own reactive computation.  When the template
accesses a reactive data source, such as by calling `Session.get` or
making a database query, this establishes a data dependency that will
cause the whole template to be re-rendered when the data changes.
This means that the amount of re-rendering for a particular change
is affected by how you've divided your HTML into templates.

Typically, the exact extent of re-rendering is not crucial, but if you
want more control, such as for performance reasons, you can use the
`{{dstache}}#isolate}}...{{dstache}}/isolate}}` helper.  Data
dependencies established inside an `#isolate` block are localized to
the block and will not in themselves cause the parent template to be
re-rendered.  This block helper essentially conveys the reactivity
benefits you would get by pulling the content out into a new
sub-template.

{{/api_box_inline}}


<h2 id="timers"><span>Timers</span></h2>

Meteor uses global environment variables
to keep track of things like the current request's user.  To make sure
these variables have the right values, you need to use
`Meteor.setTimeout` instead of `setTimeout` and `Meteor.setInterval`
instead of `setInterval`.

These functions work just like their native JavaScript equivalents.
You'll get an error if you call the native function.

{{> api_box setTimeout}}

Returns a handle that can be used by `Meteor.clearTimeout`.

{{> api_box setInterval}}

Returns a handle that can be used by `Meteor.clearInterval`.

{{> api_box clearTimeout}}
{{> api_box clearInterval}}

<h2 id="deps"><span>Deps</span></h2>

Meteor has a simple dependency tracking system which allows it to
automatically rerun templates and other computations whenever
[`Session`](#session) variables, database queries, and other data
sources change.

Unlike most other systems, you don't have to manually declare these
dependencies &mdash; it "just works". The mechanism is simple and
efficient. When you call a function that supports reactive updates
(such as a database query), it automatically saves the current
Computation object, if any (representing, for Ejemplo, the current
template being rendered).  Later, when the data changes, the function
can "invalidate" the Computation, causing it to rerun (rerendering the
template).

Applications will find [`Deps.autorun`](#deps_autorun) useful, while more
advanced facilities such as `Deps.Dependency` and `onInvalidate`
<i>callbacks</i> are intended primarily for package authors implementing new
reactive data sources.

{{> api_box deps_autorun }}

`Deps.autorun` allows you to run a function that depends on reactive data
sources, in such a way that if there are changes to the data later,
the function will be rerun.

For Ejemplo, you can monitor a cursor (which is a reactive data
source) and aggregate it into a session variable:

    Deps.autorun(function () {
      var oldest = _.max(Monkeys.find().fetch(), function (monkey) {
        return monkey.age;
      });
      if (oldest)
        Session.set("oldest", oldest.name);
    });

Or you can wait for a session variable to have a certain value, and do
something the first time it does, calling `stop` on the computation to
prevent further rerunning:

    Deps.autorun(function (c) {
      if (! Session.equals("shouldAlert", true))
        return;

      c.stop();
      alert("Oh no!");
    });

The function is invoked immediately, at which point it may alert and
stop right away if `shouldAlert` is already true.  If not, the
function is run again when `shouldAlert` becomes true.

A change to a data dependency does not cause an immediate rerun, but
rather "invalidates" the computation, causing it to rerun the next
time a flush occurs.  A flush will occur automatically as soon as
the system is idle if there are invalidated computations.  You can
also use [`Deps.flush`](#deps_flush) to cause an immediate flush of
all pending reruns.

If you nest calls to `Deps.autorun`, then when the outer call stops or
reruns, the inner call will stop automatically.  Subscriptions and
observers are also automatically stopped when used as part of a
computation that is rerun, allowing new ones to be established.  Ver
[`Meteor.subscribe`](#meteor_subscribe) for more information about
subscriptions and reactivity.

If the initial run of an autorun throws an exception, the computation
is automatically stopped and won't be rerun.

{{> api_box deps_flush }}

Normally, when you make changes (like writing to the database),
their impact (like updating the DOM) is delayed until the system is
idle. This keeps things predictable &mdash; you can know that the DOM
won't go changing out from under your code as it runs. It's also one
of the things that makes Meteor fast.

`Deps.flush` forces all of the pending reactive updates to complete.
For Ejemplo, if an event handler changes a Session
variable that will cause part of the user interface to rerender, the
handler can call `flush` to perform the rerender immediately and then
access the resulting DOM.

An automatic flush occurs whenever the system is idle which performs
exactly the same work as `Deps.flush`.  The flushing process consists
of rerunning any invalidated computations.  If additional
invalidations happen while flushing, they are processed as part of the
same flush until there is no more work to be done.  <i>callbacks</i>
registered with [`Meteor.afterFlush`](#deps_afterflush) are called
after processing outstanding invalidations.

Any auto-updating DOM elements that are found to not be in the
document during a flush may be cleaned up by Meteor (meaning that
Meteor will stop tracking and updating the elements, so that the
browser's garbage collector can delete them).  So, if you manually
call `flush`, you need to make sure that any auto-updating elements
that you have created by calling [`Meteor.render`](#meteor_render)
have already been inserted in the main DOM tree.

It is illegal to call `flush` from inside a `flush` or from a running
computation.

{{> api_box deps_nonreactive }}

Calls `func()` with `Deps.currentComputation` temporarily set to
`null`.  If `func` accesses reactive data sources, these data sources
will never cause a rerun of the enclosing computation.

{{> api_box deps_active }}

This value is useful for data source implementations to determine
whether they are being accessed reactively or not.

{{> api_box deps_currentcomputation }}

It's very rare to need to access `currentComputation` directly.  The
current computation is used implicitly by
[`Deps.active`](#deps_active) (which tests whether there is one),
[`dependency.depend()`](#dependency_depend) (which registers that it depends on a
dependency), and [`Deps.onInvalidate`](#deps_oninvalidate) (which
registers a <i>callback</i> with it).

{{> api_box deps_oninvalidate }}

Ver [*`computation`*`.onInvalidate`](#computation_oninvalidate) for more
details.

{{> api_box deps_afterflush }}

Functions scheduled by multiple calls to `afterFlush` are guaranteed
to run in the order that `afterFlush` was called.  Functions are
guaranteed to be called at a time when there are no invalidated
computations that need rerunning.  This means that if an `afterFlush`
function invalidates a computation, that computation will be rerun
before any other `afterFlush` functions are called.

<h2 id="deps_computation"><span>Deps.Computation</span></h2>

A Computation object represents code that is repeatedly rerun in
response to reactive data changes.  Computations don't have return
values; they just perform actions, such as rerendering a template on
the screen.  Computations are created using [`Deps.autorun`](#deps_autorun).
Use [`stop`](#computation_stop) to prevent further rerunning of a
computation.

Each time a computation runs, it may access various reactive data
sources that serve as inputs to the computation, which are called its
dependencies.  At some future time, one of these dependencies may
trigger the computation to be rerun by invalidating it.  When this
happens, the dependencies are cleared, and the computation is
scheduled to be rerun at flush time.

The *current computation*
([`Deps.currentComputation`](#deps_currentcomputation)) is the
computation that is currently being run or rerun (computed), and the
one that gains a dependency when a reactive data source is accessed.
Data sources are responsible for tracking these dependencies using
[`Deps.Dependency`](#deps_dependency) objects.

Invalidating a computation sets its `invalidated` property to true
and immediately calls all of the computation's `onInvalidate`
<i>callbacks</i>.  When a flush occurs, if the computation has been invalidated
and not stopped, then the computation is rerun by setting the
`invalidated` property to `false` and calling the original function
that was passed to `Deps.autorun`.  A flush will occur when the current
code finishes running, or sooner if `Deps.flush` is called.

Stopping a computation invalidates it (if it is valid) for the purpose
of calling <i>callbacks</i>, but ensures that it will never be rerun.

Ejemplo:

    // if we're in a computation, then perform some clean-up
    // when the current computation is invalidated (rerun or
    // stopped)
    if (Deps.active) {
      Deps.onInvalidate(function () {
        x.destroy();
        y.finalize();
      });
    }

{{> api_box computation_stop}}

Stopping a computation is irreversible and guarantees that it will
never be rerun.  You can stop a computation at any time, including
from the computation's own run function.  Stopping a computation that
is already stopped has no effect.

Stopping a computation causes its `onInvalidate` <i>callbacks</i> to run
immediately if it is not currently invalidated.

Nested computations are stopped automatically when their enclosing
computation is rerun.

{{> api_box computation_invalidate }}

Invalidating a computation marks it to be rerun at
[flush time](#deps_flush), at
which point the computation becomes valid again.  It is rare to
invalidate a computation manually, because reactive data sources
invalidate their calling computations when they change.  Reactive data
sources in turn perform this invalidation using one or more
[`Deps.Dependency`](#deps_dependency) objects.

Invalidating a computation immediately calls all `onInvalidate`
<i>callbacks</i> registered on it.  Invalidating a computation that is
currently invalidated or is stopped has no effect.  A computation can
invalidate itself, but if it continues to do so indefinitely, the
result will be an infinite loop.

{{> api_box computation_oninvalidate }}

`onInvalidate` registers a one-time <i>callback</i> that either fires
immediately or as soon as the computation is next invalidated or
stopped.  It is used by reactive data sources to clean up resources or
break dependencies when a computation is rerun or stopped.

To get a <i>callback</i> after a computation has been recomputed, you can
call [`Deps.afterFlush`](#deps_afterflush) from `onInvalidate`.

{{> api_box computation_stopped }}

{{> api_box computation_invalidated }}

This property is initially false.  It is set to true by `stop()` and
`invalidate()`.  It is reset to false when the computation is
recomputed at flush time.

{{> api_box computation_firstrun }}

This property is a convenience to support the common pattern where a
computation has logic specific to the first run.

<h2 id="deps_dependency"><span>Deps.Dependency</span></h2>

A Dependency represents an atomic unit of reactive data that a
computation might depend on.  Reactive data sources such as Session or
Minimongo internally create different Dependency objects for different
pieces of data, each of which may be depended on by multiple
computations.  When the data changes, the computations are
invalidated.

Dependencies don't store data, they just track the set of computations to
invalidate if something changes.  Typically, a data value will be
accompanied by a Dependency object that tracks the computations that depend
on it, as in this Ejemplo:

    var weather = "sunny";
    var weatherDep = new Deps.Dependency;

    var getWeather = function () {
      weatherDep.depend()
      return weather;
    };

    var setWeather = function (w) {
      weather = w;
      // (could add logic here to only call changed()
      // if the new value is different from the old)
      weatherDep.changed();
    };

This Ejemplo implements a weather data source with a simple getter and
setter.  The getter records that the current computation depends on
the `weatherDep` dependency using `depend()`, while the setter
signals the dependency to invalidate all dependent computations by
calling `changed()`.

The reason Dependencies do not store data themselves is that it can be
useful to associate multiple Dependencies with the same piece of data.
For Ejemplo, one Dependency might represent the result of a database
query, while another might represent just the number of documents in
the result.  A Dependency could represent whether the weather is sunny
or not, or whether the temperature is above freezing.
[`Session.equals`](#session_equals) is implemented this way for
efficiency.  When you call `Session.equals("weather", "sunny")`, the
current computation is made to depend on an internal Dependency that
does not change if the weather goes from, say, "rainy" to "cloudy".

Conceptually, the only two things a Dependency can do are gain a
dependent and change.

A Dependency's dependent computations are always valid (they have
`invalidated === false`).  If a dependent is invalidated at any time,
either by the Dependency itself or some other way, it is immediately
removed.

{{> api_box dependency_changed }}

{{> api_box dependency_depend }}

`dep.depend()` is used in reactive data source implementations to record
the fact that `dep` is being accessed from the current computation.

{{> api_box dependency_hasdependents }}

For reactive data sources that create many internal Dependencies,
this function is useful to determine whether a particular Dependency is
still tracking any dependency relationships or if it can be cleaned up
to save memory.

<h2 id="ejson"><span>EJSON</span></h2>

EJSON is an extension of JSON to support more types. It supports all JSON-safe
types, as well as:

 - **Date** (JavaScript `Date`)
 - **Binary** (JavaScript `Uint8Array` or the
   result of [`EJSON.newBinary`](#ejson_new_binary))
 - **User-defined types** (Ver [`EJSON.addType`](#ejson_add_type).  For Ejemplo,
 [`Meteor.Collection.ObjectID`](#collection_object_id) is implemented this way.)

All EJSON serializations are also valid JSON.  For Ejemplo an object with a date
and a binary buffer would be serialized in EJSON as:

    {
      "d": {"$date": 1358205756553},
      "b": {"$binary": "c3VyZS4="}
    }

Meteor supports all built-in EJSON data types in publishers, method arguments
and results, Mongo databases, and [`Session`](#session) variables.

{{> api_box ejsonParse}}

{{> api_box ejsonStringify}}

{{> api_box ejsonFromJSONValue}}

{{> api_box ejsonToJSONValue}}

{{> api_box ejsonEquals}}

{{> api_box ejsonClone}}

{{> api_box ejsonNewBinary}}

Buffers of binary data are represented by `Uint8Array` instances on JavaScript
platforms that support them.  On implementations of JavaScript that do not
support `Uint8Array`, binary data buffers are represented by standard arrays
containing numbers ranging from 0 to 255, and the `$Uint8ArrayPolyfill` key
set to `true`.

{{> api_box ejsonAddType}}

When you add a type to EJSON, Meteor will be able to use that type in:

 - publishing objects of your type if you pass them to publish handlers.
 - allowing your type in the return values or arguments to
   [methods](#methods_header).
 - storing your type client-side in Minimongo.
 - allowing your type in [`Session`](#session) variables.

{{#note}}

  MongoDB cannot store most user-defined types natively en el servidor.  Your
  type will work in Minimongo, and you can send it to the client using a custom
  publisher, but MongoDB can only store the types defined in
  [BSON](http://bsonspec.org/).

{{/note}}

Instances of your type should implement the following interface:

{{> api_box ejsonTypeClone}}

{{> api_box ejsonTypeEquals}}

The `equals` method should define an [equivalence
relation](http://en.wikipedia.org/wiki/Equivalence_relation).  It should have
the following properties:

 - *Reflexivity* - for any instance `a`: `a.equals(a)` must be true.
 - *Symmetry* - for any two instances `a` and `b`: `a.equals(b)` if and only if `b.equals(a)`.
 - *Transitivity* - for any three instances `a`, `b`, and `c`: `a.equals(b)` and `b.equals(c)` implies `a.equals(c)`.

{{> api_box ejsonTypeName}}
{{> api_box ejsonTypeToJSONValue}}

For Ejemplo, the `toJSONValue` method for
[`Meteor.Collection.ObjectID`](#collection_object_id) could be:

    function () {
      return this.toHexString();
    };

<h2 id="meteor_http"><span>Meteor.http</span></h2>

`Meteor.http` provides an HTTP API on the client and server.  To use
these functions, add the HTTP package to your project with `$ meteor add
http`.

{{> api_box httpcall}}

This function initiates an HTTP request to a remote server. It returns
a result object with the contents of the HTTP response.  The result
object is detailed below.

en el servidor, this function can be run either synchronously or
asynchronously.  If the <i>callback</i> is omitted, it runs synchronously,
and the results are returned once the request completes. This is
useful when making server-to-server HTTP API calls from within Meteor
methods, as the method can succeed or fail based on the results of the
synchronous HTTP call.  In this case, consider using
[`this.unblock()`](#method_unblock) to allow other methods to run in
the mean time.  On the client, this function must be used
asynchronously by passing a <i>callback</i>.

Both HTTP and HTTPS protocols are supported.  The `url` argument must be
an absolute URL including protocol and host name en el servidor, but may be
relative to the current host on the client.  The `query` option
replaces the query string of `url`.  Parameters specified in `params`
that are put in the URL are appended to any query string.
For Ejemplo, with a `url` of `"/path?query"` and
`params` of `{foo:"bar"}`, the final URL will be `"/path?query&foo=bar"`.

The `params` are put in the URL or the request body, depending on the
type of request.  In the case of request with no bodies, like GET and
HEAD, the parameters will always go in the URL.  For a POST or other
type of request, the parameters will be encoded into the body with a
standard `x-www-form-urlencoded` content type, unless the `content`
or `data` option is used to specify a body, in which case the
parameters will be appended to the URL instead.

The <i>callback</i> receives two arguments, `error` and `result`.  The `error`
argument will contain an Error if the request fails in any way,
including a network error, time-out, or an HTTP status code in the 400
or 500 range.  The result object is always
defined. When run in synchronous mode, the `result` is returned from the
function, and the `error` value is a stored as a property in `result`.

Contents of the result object:

<dl class="objdesc">

<dt><span class="name">statusCode</span>
  <span class="type">Number</span></dt>
<dd>Numeric HTTP result status code, or <code>null</code> on error.</dd>

<dt><span class="name">content</span>
  <span class="type">String</span></dt>
<dd>The body of the HTTP response as a string.</dd>

<dt><span class="name">data</span>
  <span class="type">Object or <code>null</code></span></dt>
<dd>If the response headers indicate JSON content, this contains the body of the document parsed as a JSON object.</dd>

<dt><span class="name">headers</span>
  <span class="type">Object</span></dt>
<dd>A dictionary of HTTP headers from the response.</dd>

<dt><span class="name">error</span>
  <span class="type">Error</span></dt>
<dd>Error object if the request failed. Matches the <code>error</code> <i>callback</i> parameter.</dd>


</dl>

Ejemplo server method:

    Meteor.methods({checkTwitter: function (userId) {
      this.unblock();
      var result = Meteor.http.call("GET", "http://api.twitter.com/xyz",
                                    {params: {user: userId}});
      if (result.statusCode === 200)
         return true
      return false;
    }});

Ejemplo asynchronous HTTP call:

    Meteor.http.call("POST", "http://api.twitter.com/xyz",
                     {data: {some: "json", stuff: 1}},
                     function (error, result) {
                       if (result.statusCode === 200) {
                         Session.set("twizzled", true);
                       }
                     });


{{> api_box http_get}}
{{> api_box http_post}}
{{> api_box http_put}}
{{> api_box http_del}}


<h2 id="email"><span>Email</span></h2>

The `email` package allows sending email from a Meteor app. To use it, add the
package to your project with `$ meteor add email`.

The server reads from the `MAIL_URL` environment variable to determine how to
send mail. Currently, Meteor supports sending mail over SMTP; the `MAIL_URL`
environment variable should be of the form
`smtp://USERNAME:PASSWORD@HOST:PORT/`. For apps deployed with `meteor deploy`,
`MAIL_URL` defaults to an account (provided by
[Mailgun](http://www.mailgun.com/)) which allows apps to send up to 200 emails
per day; you may override this default by assigning to `process.env.MAIL_URL`
before your first call to `Email.send`.

If `MAIL_URL` is not set (ej, when running your application locally),
`Email.send` outputs the message to standard output instead.

{{> api_box email_send }}

You must provide the `from` option and at least one of `to`, `cc`, and `bcc`;
all other options are optional.

`Email.send` only works en el servidor. Here is an Ejemplo of how a
client could use a server method call to send an email. (In an actual
application, you'd need to be careful to limit the emails that a
client could send, to prevent your server from being used as a relay
by spammers.)

    // In your server code: define a method that the client can call
    Meteor.methods({
      sendEmail: function (to, from, subject, text) {
        // Let other method calls from the same client start running,
        // without waiting for the email sending to complete.
        this.unblock();

        Email.send({
          to: to,
          from: from,
          subject: subject,
          text: text
        });
      }
    });

    // In your client code: asynchronously send an email
    Meteor.call('sendEmail',
                'alice@Ejemplo.com',
                'bob@Ejemplo.com',
                'Hello from Meteor!',
                'This is a test of Email.send.');

{{/better_markdown}}
</template>






<template name="api_box">
<div class="api {{bare}}">
<h3 id="{{id}}">
  <a class="name selflink" href="#{{id}}">{{{name}}}</a>
{{#if locus}}
  <span class="locus">{{locus}}</span>
{{/if}}
</h3>

<div class="desc">
{{#each descr}}{{#better_markdown}}{{{this}}}{{/better_markdown}}{{/each}}
</div>

{{#if args}}
<h4>Arguments</h4>
{{> api_box_args args}}
{{/if}}

{{#if options}}
<h4>Options</h4>
{{> api_box_args options}}
{{/if}}

{{#if body}}
{{#better_markdown}}{{{body}}}{{/better_markdown}}
{{/if}}

</div>

</template>



<template name="api_box_args">
<dl class="args">
{{#each this}}
<dt><span class="name">{{{name}}}</span>
  <span class="type">
    {{#if type_link}}
      <a href="#{{type_link}}">{{{type}}}</a>
    {{else}}
      {{{type}}}
    {{/if}}
  </span></dt>
<dd>{{#better_markdown}}{{{descr}}}{{/better_markdown}}</dd>
{{/each}}
</dl>
</template>


<template name="api_section_helper">
<h2 id="{{id}}"><a href="#{{id}}" class="selflink"><span>{{name}}</span></a></h2>
</template>
