<template name="api">
{{#better_markdown}}

<h1 id="api">La API de Meteor</h1>

Traducción <b>no-oficial</b> al Español 

Su código JavaScript se puede ejecutar en dos entornos: el *client* (browser), y
el *server* (un contenedor [Node.js](http://nodejs.org/) en un server).  Para cada 
función de esta referencia del API , indicaremos si la función está disponible sólo
en el cliente, sólo en el servidor, o en cualquier lugar *Anywhere*.

<h2 id="core"><span>Meteor Core</span></h2>

{{> api_box isClient}}
{{> api_box isServer}}
{{> api_box startup}}

En un servidor, la función se ejecutará tan pronto como el proceso del servidor 
haya terminado de iniciarse. En un cliente, la función se ejecutará tan pronto como 
el DOM esté listo.

Los <i>callbacks</i> de `inicio` son llamados en el mismo orden que se hicieron 
las llamadas a `Meteor.startup`.

En un cliente, los <i>callbacks</i> `startup` de paquetes inteligentes serán llamado 
primero, seguido de los templates en el `<body>` de sus archivos `.html`,
seguido por el código de su aplicación. 

    // On server startup, if the database is empty, create some initial data.
    // En el arranque del servidor, si la base de datos está vacía,  
    // se crean algunos datos iniciales.
    if (Meteor.isServer) {
      Meteor.startup(function () {
        if (Rooms.find().count() === 0) {
          Rooms.insert({name: "Initial room"});
        }
      });
    }

{{> api_box absoluteUrl}}

{{> api_box settings}}

{{> api_box release}}

<h2 id="publishandsubscribe"><span>Publicar y suscribirse</span></h2>

Estas funciones controlan cómo los servidores Meteor publican conjuntos de registros y
cómo los clientes pueden suscribirse a estos conjuntos.

{{> api_box publish}}

Para publicar registros de los clientes, llame a `Meteor.publish` en el servidor con dos
parámetros: el nombre del conjunto de registros, y  la <i>función de publicación</i> *publish function*
que Meteor llamará cada vez que un cliente se suscriba al nombre.

Las funciones de publicación pueden devolver un 
[`Collection.Cursor`](#meteor_collection_cursor), en tal caso, Meteor 
publicará los documentos de cursor. Usted también puede devolver un <i>array</i> de
`Collection.Cursor`s, en tal caso Meteor publicará todos los cursores.

{{#warning}}
Si usted devuelve múltiples cursores en un array, 
en la actualidad todos deben ser de diferentes colecciones.
Esperamos levantar esta restricción en una versión futura.
{{/warning}}

    // server: publish the rooms collection, minus secret info.
    Meteor.publish("rooms", function () {
      return Rooms.find({}, {fields: {secretInfo: 0}});
    });

    // ... and publish secret info for rooms where the logged-in user
    // is an admin. If the client subscribes to both streams, the records
    // are merged together into the same documents in the Rooms collection.
    Meteor.publish("adminSecretInfo", function () {
      return Rooms.find({admin: this.userId}, {fields: {secretInfo: 1}});
    });

    // publish dependent documents and simulate joins
    Meteor.publish("roomAndMessages", function (roomId) {
      return [
        Rooms.find({_id: roomId}, {fields: {secretInfo: 0}}),
        Messages.find({roomId: roomId})
      ];
    });

En caso contrario, la función de publicación debe llamar a las funciones 
[`added`](#publish_added) (cuando un nuevo documento se añade al conjunto de 
registros publicados), [`changed`](#publish_changed) 
(Cuando algunos campos en un documento en el conjunto de registros se cambien o
borren), y [`removed`](#publish_removed) 
(cuando los documentos se eliminen del conjunto de registros publicados) 
para informar a los suscriptores sobre los documentos.
Estos métodos son proporcionados por `this` en la función de publicación.

<!-- TODO discuss ready -->

Ejemplo:

    // server: publish the current size of a collection
    Meteor.publish("counts-by-room", function (roomId) {
      var self = this;
      var count = 0;
      var initializing = true;
      var handle = Messages.find({roomId: roomId}).observeChanges({
        added: function (id) {
          count++;
          if (!initializing)
            self.changed("counts", roomId, {count: count});
        },
        removed: function (id) {
          count--;
          self.changed("counts", roomId, {count: count});
        }
        // don't care about moved or changed
      });

      // Observe only returns after the initial added <i>callbacks</i> have
      // run.  Now return an initial value and mark the subscription
      // as ready.subscrip
      initializing = false;
      self.added("counts", roomId, {count: count});
      self.ready();

      // Stop observing the cursor when client unsubs.
      // Stopping a subscription automatically takes
      // care of sending the client any removed messages.
      self.onStop(function () {
        handle.stop();
      });
    });

    // client: declare collection to hold count object
    Counts = new Meteor.Collection("counts");

    // client: subscribe to the count for the current room
    Deps.autorun(function () {
      Meteor.subscribe("counts-by-room", Session.get("roomId"));
    });

    // client: use the new collection
    console.log("Current room has " +
                Counts.findOne(Session.get("roomId")).count +
                " messages.");

{{#warning}}
Meteor emitirá un mensaje de advertencia si usted llama a `Meteor.publish` en un
proyecto que incluye el paquete `autopublish`. Su función de publicación 
seguirá funcionando.
{{/warning}}

{{> api_box subscription_userId}}
Esto es constante. Sin embargo, si el usuario que ha iniciado sesión, cambia,
la función de publicación se vuelve a ejecutar con el nuevo valor.

{{> api_box subscription_added}}
{{> api_box subscription_changed}}
{{> api_box subscription_removed}}
{{> api_box subscription_ready}}

{{> api_box subscription_onStop}}

Si se llama [`observe`](#observe) o [`observeChanges`](#observe_changes) en su
manejador de publicación, este es el lugar para detener <i>observes</i>.

{{> api_box subscription_error}}
{{> api_box subscription_stop}}

{{> api_box subscribe}}
 
Cuando se suscribe a un conjunto de registros, le dice al servidor que envie 
información al cliente. El cliente almacena estos archivos en local [Minimongo
collections](#meteor_collection), con el mismo nombre que el argumento `collection`
utilizado con el controlador de publicación los <i>callbacks</i> `added`, `changed`, and `removed`.  
Meteor encolará atributos entrantes hasta que usted declare la
[`Meteor.Collection`](#meteor_collection) en el cliente con el
correspondiente nombre de la colección.

    // Bien para suscribirse (y posiblemente recibir datos) antes de declarar
    // La colección cliente que lo sostendrá.  Asume "allplayers"
    // publica los datos del servidor de la colección "players"
    Meteor.subscribe("allplayers");
    ...
    // colas de cliente registran los <i>players</i> entrantes hasta que ...
    ...
    Players = new Meteor.Collection("players");

El cliente verá un documento si el documento se encuentra actualmente 
en el conjunto de registros publicados de cualquiera de sus suscripciones.

El <i>callback</i> `onReady`  es llamado sin argumentos cuando
el servidor [marca la suscripción como <i>onReady</i>](#publish_ready). 
El <i>callback</i> `onError`  es llamado con un [`Meteor.Error`](#meteor_error) 
si la suscripción falla o es terminada por el servidor.

`Meteor.subscribe` devuelve un identificador de suscripción, que es un objeto
con los siguientes métodos:

<dl class="<i>callbacks</i>">
{{#dtdd "stop()"}}
Cancelar la suscripción. Esto normalmente se traducirá
en el servidor dirigiendose al cliente para eliminar los datos de la suscripción
de la memoria caché del cliente.

{{/dtdd}}

{{#dtdd "ready()"}}
True si el servidor ha [marcado la suscripción como ready](#publish_ready). 
Una fuente de datos reactiva.
{{/dtdd}}
</dl>

Si usted llama `Meteor.subscribe` dentro de una [computación reactiva](#reactivity),
por ejemplo utilizando [`Deps.autorun`](#deps_autorun), 
la suscripción será automáticamente cancelada cuando el cómputo se invalide 
o se detenga, no es necesario llamar `stop` en suscripciones efectuadas 
desde el interior de `autorun`. 
Sin embargo, si en la próxima iteración de la ejecución de su función subscribe el
mismo conjunto de registros  (mismo nombre y parámetros),
Meteor es lo suficientemente inteligente como para evitar el
derroche de un desinscribirse/reinscribirse. 

Por ejemplo:

    Deps.autorun(function () {
      Meteor.subscribe("chat", {room: Session.get("current-room")});
      Meteor.subscribe("privateMessages");
    });
 
Esto le suscribe a los mensajes de chat en la sala actual y a sus
mensajes privados. Cuando cambie de habitación llamando 
`Session.set("current-room", "new-room")`, 
Meteor se suscribirá a los mensajes de la nueva sala de chat, 
se dará de baja de los mensajes de la sala original
y se mantendrá suscrito a sus mensajes privados. 

Si más de una suscripción envía valores en conflicto para un campo (el mismo
nombre de la colección, ID de documento, y el nombre de campo), entonces el valor en el
cliente será uno de los valores publicados, elegido arbitrariamente.

<h2 id="methods_header"><span>Methods</span></h2>

Los métodos son funciones remotas que los clientes Meteor pueden invocar.

{{> api_box methods}}

Ejemplo:

    Meteor.methods({
      foo: function (arg1, arg2) {
        // .. hacer algo..
        if (quiere lanzar un error)
          throw new Meteor.Error(404, "No puedo encontrar mi pantalones");
        return "se devuelve algún valor";
      },
      
      bar: function () {
        // ..  hacer otra cosa..
        return "baz";
      }
    });

Llamando `methods` en las funciones definidas en el
servidor que pueden ser llamados de forma remota por los clientes.

  Deben devolver un valor [EJSON](#ejson)-able o lanzar una
excepción. Dentro del método de invocación, `this` se une a un objeto 
del método de invocación, el cual presenta lo siguiente:

* `isSimulation`: un valor  booleano, true si esta invocación es un <i>stub</i>.
* `unblock`: cuando se le llama, permite que el método siguiente de este cliente 
empiece a ejecutarse.
* `userId`: el id del usuario actual.
* `setUserId`: una función que asocia el cliente actual con un usuario.

Llamar a `methods` en el cliente define funciones *stub* asociadas con 
los métodos de servidor del mismo nombre. Usted no tiene que definir un stub 
para su método si no desea hacerlo. En ese caso, las llamadas a métodos son 
como las llamadas a procedimientos remotos en otros sistemas,
y usted tendrá que esperar los resultados del servidor. 

Si usted define un <i>stub</i>, cuando un cliente invoca un método del servidor
también lo hará su <i>stub</i> en paralelo. En el cliente, el valor de retorno de
un <i>stub</i> es ignorado. Los <i>Stubs</i> se ejecutan por sus efectos secundarios:

están destinados a *simular* el resultado de lo que el método del servidor va a hacer
pero sin esperar el retardo de ida y vuelta. Si un <i>stub</i> lanza una 
excepción será registrada en la consola.

Se utilizan métodos todo el tiempo, porque los mutadores de bases de datos
([`insert`](#insert), [`update`](#update), [`remove`](#remove)) están implementdos
como métodos. Cuando se llama cualquiera de estas funciones en el cliente, 
se está invocando su versión de <i>stub</i> que actualiza la memoria caché local, 
y envía la misma petición de escritura al servidor. Cuando el servidor responde, 
el cliente actualiza la caché local con lo que se ha escrito realmente en el servidor.

{{> api_box method_invocation_userId}}

El ID de usuario es una cadena arbitraria &mdash; típicamente el id de registro 
del usuario en la base de datos. Usted puede establecerlo con la función`setUserId` 
Si está utilizando las cuentas [Meteor accounts system](#accounts_api) 
entonces esto es manejado por usted.

{{> api_box method_invocation_setUserId}}

Llame esta función para modificar el actual usuario conectado 
en la conexión que hizo esta llamada al método.
Esto simplemente establece el valor de `userId` para futuras llamadas al método
recibidas en esta conexión. Pase `null` para salir <i>log out</i> de la conexión.

Si usted está utilizando el [built-in Meteor accounts system](#accounts_api) 
entonces este debe corresponder al campo `_id` del documento en la colección
[`Meteor.users`](#meteor_users).

`setUserId` no es retroactivo. Afecta a la llamada al método actual 
y cualquier futura llamada al método en la conexión.
Cualquier anterior llamada al método en esta conexión seguirá viendo el valor de
`userId` que estaba vigente cuando comenzaron.

{{> api_box method_invocation_isSimulation}}

{{> api_box method_invocation_unblock}}

En el servidor, métodos de un cliente dado se ejecutan uno a la vez. 
La invocación Nº 1 de un cliente, no se iniciará hasta que la invocación enésima
retorne.
Sin embargo, usted puede cambiar esto llamando `this.unblock`. 
Esto permitirá que la invocación N+1th  empiece a ejecutarse  en
una nueva fibra.

{{> api_box error}}

Si desea devolver un error desde un método, lanze una excepción. 
Los métodos pueden arrojar cualquier tipo de excepción.
Pero `Meteor.Error` es la única clase de excepción que el servidor enviará al
cliente. Si una función método lanza una excepción diferente, entonces será
asignada a `Meteor.Error(500, "Internal server error")` <i>on the wire.</i> al momento.

{{> api_box meteor_call}}

Esta es la forma de invocar un método  Se ejecutará el método en el servidor.  Si un 
<i>stub</i> está disponible, tambien ejecutará el <i>stub</i> en el cliente.  (Ver 
también [`Meteor.apply`](#meteor_apply), que es idéntico a `Meteor.call` excepto que
usted specifique los parametros como un <i>array</i> en lugar de como argumentos 
separados y puede especificar varias opciones controlando cómo se ejecuta el método.)

Si usted incluye una función <i>callback</i> como último argumento (que no puede ser un 
argumento para el método, ya que las funciones no son serializables),
el método se ejecutará de forma asíncrona: no retornará nada en particular 
y no lanzará una excepción. Cuando el método se haya completado (que puede 
o no puede suceder antes de que `Meteor.call` retorne), el <i>callback</i> se invocará
con dos argumentos: `error` and `result`. Si un error fue lanzado, entonces
`error` será el objeto excepción. De lo contrario, `error` será indefinido y
el valor de retorno (posiblemente indefinido, <i>undefined</i>) estará en `result`.

    // async call
    Meteor.call('foo', 1, 2, function (error, result) { ... } );

Si usted no pasa un "<i>callback</i>" al servidor, la invocación del método se 
bloqueará hasta la conclusión del método. Eventualmente se devolverá el valor 
de retorno del método, o será una excepción si el método arrojó una <i>exception</i>.
(Posiblemente asignada a 500 Server Error si la 
excepción ocurrió remotamente y no fuera una excepción `Meteor.Error`.)

    // sync call
    var result = Meteor.call('foo', 1, 2);

En el cliente, si usted no pasa un <i>callback</i> y no esta en el interior de un stub,
`call` retornará `undefined`, y usted no tendrá manera de obtener el valor de retorno 
del método. Esto es porque el cliente no tiene fibras, así que no hay realmente ninguna
manera que se pueda bloquear la ejecución remota de un método 

Por último, si usted está dentro de un <i>stub</i> en el cliente y llama otro
método, el otro método no es ejecutado (RPC no se genera, nada
"real" sucede). Si ese otro método tiene un <i>stub</i>, ese <i>stub</i> sustituye al 
del método y se ejecuta. El valor de retorno de la llamada al método es el valor de retorno 
de la función stub.  El cliente no tiene nungún problema en la ejecución de un <i>stub</i> 
sincrónicamente, y es por eso que está bien que el cliente utilice la forma sincrona 
`Meteor.call` dentro de un cuerpo de método, como se describió anteriormente.

Meteor hace un seguimiento en la base de datos de las escrituras realizadas por métodos,
tanto en el cliente como en el servidor, y no invoca `async<i>callback</i>` 
hasta que todas las escrituras en el servidor reemplazan las escrituras del stub's
en la <i>caché</i> local. En algunos casos, puede haber un retraso entre el valor devuelto 
por el método que está disponible y las escrituras que son visibles: por ejemplo, si otro 
método aún pendiente escribió en el mismo documento la memoria caché local puede 
no estar actualizada hasta que el otro método finaliza también. Si quiere procesar el 
resultado del método tan pronto como llegue del servidor,  incluso si la escritura del 
método no está disponibles todavía, usted puede especificar un 
`onResultReceived` <i>callback</i> a [`Meteor.apply`](#meteor_apply).

{{> api_box meteor_apply}}

`Meteor.apply` es lo mismo que `Meteor.call`, excepto que los argumentos del método son 
pasados como un <i>array</i> en vez de hacerlo directamente como argumentos, y puede especificar
las opciones acerca de como el cliente ejecuta el método.

<h2 id="connections"><span>Server connections</span></h2>

Estas funciones gestionan y controlan la conexión de red entre el cliente Meteor y el servidor. 


{{> api_box status}}

Este método devuelve el estado de la conexión entre el cliente y el servidor. 
El valor de retorno es un objeto con los siguientes campos:

<dl class="objdesc">
{{#dtdd name="connected" type="Boolean"}}
  <i>True</i> si está conectado actualmente al servidor. Si <i>false</i>, cambia 
  y las invocaciones de método se pondrán en cola hasta que la conexión se restablezca. 
{{/dtdd}}

{{#dtdd name="status" type="String"}}
  Describe el estado actual de la reconexión. Los valores posibles
  son `connected` (la conexión está en funcionamiento),
  `connecting` (desconectado e intentando abrir una nueva conexión), 
  `failed` (el intento de conectar falla permanentemente; e.g., el cliente
  y el servidor soportan diferentes versiones de <i>DDP</i>) 
  y `waiting` (intento de conexión fracasado y esperando para intentar reconectarse).
{{/dtdd}}

{{#dtdd name="retryCount" type="Number"}}
  El número de veces que el cliente ha inentado reconectarse desde que la 
  conexiónn se perdió. 0 cuando está conectado.
{{/dtdd}}

{{#dtdd name="retryTime" type="Number or undefined"}}
  El tiempo estimado del siguiente intento de reconexión. Para convertir esto
  en un intervalo hasta la próxima reconexión, utilice 
  `retryTime - (new Date()).getTime()`. Esta clave se 
  establece sólo cuando `status` es `waiting`.
{{/dtdd}}

{{#dtdd name="reason" type="String or undefined"}}
  Si `status` es `failed`, una descripción de ¿Por qué falló la conexión?. 
{{/dtdd}}
</dl>

En vez de utilizar <i>callbacks</i> para notificarle los cambios, esto es
una fuente de datos [reactive](#reactivity). Se puede utilizar en un
[template](#templates) o [computation](#deps_autorun)
para obtener actualizaciones en tiempo real.

{{> api_box reconnect}}

{{> api_box connect}}

Para llamar métodos en otra aplicación Meteor o suscribirse a sus
conjuntos de sus datos, llame `Meteor.connect` con la dirección URL de la aplicación.
`Meteor.connect` devuelve un objeto que proporciona:

* `subscribe` -
  Suscribirse a un conjunto de registros. Ver
  [Meteor.subscribe](#meteor_subscribe).
* `call` -
  Invocar un método. Ver [Meteor.call](#meteor_call).
* `apply` -
  Invocar un método con un array de argumentos. Ver
  [Meteor.apply](#meteor_apply).
* `methods` -
  Definir sólo-cliente stubs par métodos definidos en el servidor remotoe. Ver
  [Meteor.methods](#meteor_methods).
* `status` -
  Obtener el estado actual de la conexión. Ver
  [Meteor.status](#meteor_status).
* `reconnect` -
  Ver [Meteor.reconnect](#meteor_reconnect).
* `onReconnect` - Ponga esto en la función que se llame como primer paso para reconectar.
  Esta función puede llamar a los métodos, que se ejecutarán antes de cualquier 
  otro método pendiente. Por ejemplo,esto se puede utilizar para volver a reestablecer
  el contexto de autenticación adecuado en la nueva conexión.

Por defecto, los clientes abren una conexión con el servidor desde el que están cargados.
Cuando usted llama `Meteor.subscribe`, `Meteor.status`, `Meteor.call`, y
`Meteor.apply`, usted está utilizando una conexión, de nuevo, con el servidor por defecto.

{{#warning}}
En esta versión, `Meteor.connect` sólo puede ser llamado en el cliente.
Los Servidores no pueden todavía conectarse a otros servidores.
{{/warning}}

<h2 id="collections"><span>Collections</span></h2>

Meteor almacena los datos en *collections*. Para empezar, declare una
colección con `new Meteor.Collection`.

{{> api_box meteor_collection}}

Llamar esta función es análoga a la declaración de un modelo en un tradicional framework ORM
(Object-Relation Mapper)-céntrica . Se establece una *collection* (un espacio de almacenamiento 
de registros, o "documentos") que pueden ser utilizados para almacenar un tipo particular 
de información, como usuarios, mensajes , puntuaciones, tareas pendientes,
o cualquier cosa importante para su aplicación.  
Cada documento es un objeto EJSON. Incluye un `_id` con la
propiedad de ser un valor único en la colección,
que Meteor especificó al crear el documento.

    // código común en el cliente y el servidor <i>livedata-managed</i>
    // coleción mongo.
    Chatrooms = new Meteor.Collection("chatrooms");
    Messages = new Meteor.Collection("messages");

La función devuelve un objeto con métodos para [`insert`](#insert)
los documentos de la colección, [`update`](#update) sus propiedades, y
[`remove`](#remove), y a [`find`](#find) los documentos de la
colección que coincidan con criterios arbitrarios. la forma en que estos métodos trabajan es
compatible con el popular <i>Mongo database API</i>. La misma <i>database API</i>
 funciona tanto en el cliente como en el servidor (ver abajo).

    // return array of my messages
    var myMessages = Messages.find({userId: Session.get('myUserId')}).fetch();

    // create a new message
    Messages.insert({text: "Hello, world!"});

    // mark my first message as "important"
    Messages.update(myMessages[0]._id, {$set: {important: true}});

Si usted pasa un `name` cuando crea la colección, entonces está 
declarando una colección persistente &mdash; que se almacena en 
el servidor y es visto por todos los usuarios. Ambos el código de cliente 
y el de servidor pueden acceder a la misma colección utilizando la misma <i>API</i>.

Especificamente, cuando usted pasa un `name`, esto es lo que sucede:

* En el servidor, una colección con este nombre se crea en un servidor <i>back-end</i> Mongo. 
Cuando llame métodos en esta colección en el servidor,
se traducen directamente en las operaciones normales de Mongo (después de comprobar 
que coinciden con sus [reglas de control de acceso](#allow)).

* En el cliente, una instancia Minimongo es
creada. Minimongo es esencialmente una implementación no persistente, 
en memoria, de Mongo en JavaScript puro.  
Sirve una caché local que almacena sólo el subconjunto de la base de datos
de la que este cliente está trabajando.
Las consultas sobre el cliente ([`find`](#find))se sirven directamente de
esta caché, sin hablar con el servidor.

* Cuando usted escriba en la base de datos del cliente ([`insert`](#insert),
[`update`](#update), [`remove`](#remove)), el comando se ejecuta
inmediatamente en el cliente, y, simultaneamente, se envían al
al servidor y se ejecutan tambien allí. El paquete `livedata` es el
responsable de esto.

Si pasa `null` como el `name`, entonces usted va a crear una colección local.
Collection. Que no es sincronizada en ningún lugar; es sólo una memoria local,
que soporta las operaciones <i>Mongo-style</i> [`find`](#find), [`insert`](#insert),
[`update`](#update), y [`remove`](#remove). (En ambos el
cliente y el servidor, esta memoria local se implementa mediante Minimongo.

De forma predeterminada, Meteor publica automáticamente todos los documentos de su colección 
para cada cliente conectado.  Para desactivar este comportamiento, quite el
el paquete `autopublish`:

    $ meteor remove autopublish

y llame en su lugar [`Meteor.publish`](#meteor_publish) para especificar qué partes de su
colección deben ser publicados y para que usuarios.

    // Crear una colección llamada <i>Posts</i> y poner un documento en él. El
    // documento será immediatamente visible en la copia local de la
    // colección. Se escribirá en la base de datos <i>server-side</i>
    // una fracción de segundo más tarde, y una fracción de segundo
    // después de eso, se sincronizará con los otros clientes
    // que se esten suscritos a una consulta que los incluya (Ver
    // Meteor.subscribe and autopublish)
    Posts = new Meteor.Collection("posts");
    Posts.insert({title: "Hello world", body: "First post"});

    // Los cambios son visibles de inmediato -- sin esperara una ida y vuelta <i>round trip</i>
    // al servidor
    assert(Posts.find().count() === 1);

    // Crea una colección local, temporal. Funciona como cualquier otra
    // colección, pero no envía los cambios al servidor, y no    
    // puede recibir ningún dato de los suscriptores.
    Scratchpad = new Meteor.Collection;
    for (var i = 0; i < 10; i++)
      Scratchpad.insert({number: i * 2});
    assert(Scratchpad.find({number: {$lt: 9}}).count() === 5);

Si especifica una opción `transform` a la `Collection` o cualquiera de sus
métodos de recuperación, los documentos se pasan a través de la función `transform` 
antes de ser devueltos o pasados a los <i><i>callbacks</i></i>. Esto le permite añadir métodos 
o por otra parte modificar el contenido de su colección desde la representación de su 
base de datos. También puede especificar `transform` en una determinada llamada a `find`, 
`findOne`, `allow`, o `deny`.

    // Una clase de animal que obtiene un documento en su constructor
    Animal = function (doc) {
      _.extend(this, doc);
    };
    _.extend(Animal.prototype, {
      makeNoise: function () {
        console.log(this.sound);
      }
    });

    //Define una colección que utiliza Animal como documento
    Animals = new Meteor.Collection("Animals", {
      transform: function (doc) { return new Animal(doc); }
    });

    // Crear un Animal y llamar a su método <i>makeNoise</i>
    Animals.insert({name: "raptor", sound: "roar"});
    Animals.findOne({name: "raptor"}).makeNoise(); // prints "roar"

Las funciones `transform` no son llamadas reactivamente. Si quiere añadir un atributo 
que cambie dinámicamente a un objeto, hágalo con una función que calcule el valor en 
el momento que se llama, no calculando el atributo `transform` al momento.

{{#warning}}
En esta versión, Minimongo tiene algunas limitaciones:

* `$pull` en modificadores sólo puede aceptar ciertos
tipos de selectores.
* `$` referirse a la posición de array que coincide no está soportado en modifier.
* `findAndModify`, funciones upsert, aggregate, y
map/reduce no estan suportadas.

Todo esto se abordará en una próxima versión. 
Para notas completas de la versión Minimongo, consulte
Ver packages/minimongo/NOTES en el repositorio.
{{/warning}}

{{#warning}}
Minimongo actualmente no tienen índices. Es raro que esto sea un problema,
ya que es inusual que un cliente tenga datos suficientes para que un índice 
valga la pena.
{{/warning}}

{{> api_box find}}

`find` devuelve un cursor.  No tiene acceso inmediato a la base de datos 
o devuelve documentos.  Los cursores proporcionan `fetch` para retornar 
todos los documentos coincidentes, `map` y `forEach` para iterar sobre 
todos los documentos coincidentes, y `observe` y `observeChanges` 
para registrar <i>callbacks</i> cuando el conjunto de documentos coincidentes cambia.

{{#warning}}
La colección de cursores no son instantáneas de la consulta.  Si la base de 
datos cambia entre llamadas `Collection.find` y extrae los resultados
del cursor, o mientras obtiene resultados desde el cursor,
estos cambios, pueden o no pueden, aparecer en el conjunto de resultados.
{{/warning}}

Cursor es una fuente de datos reactiva. La primera vez que recupera n
documentos de cursor con `fetch`, `map`, o `forEach` dentro de una 
computación reactiva (ej, una plantilla o 
[`autorun`](#deps_autorun)),  Meteor registrará una 
dependencia de los datos subyacentes.
Cualquier cambio en la colección que cambie los documentos en un cursor 
disparará un recomputación. Para desactivar este comportamiento, pase
`{reactive: false}` como una opción para `find`.

{{> api_box findone}}

Equivalente a `find(selector, options).fetch()[0]`.

{{> api_box insert}}

Añade un documento a la colección. Un documento es sólo un objeto, y
y sus campos pueden contener cualquier combinación de tipos de datos
 EJSON-compatible (arrays, objects, numbers, strings, `null`, true, and false).

`insert` generará un ID único para el objeto que usted pase, lo inserta
en la base de datos, y retorna el ID. Cuando `insert` se llama desde
código de cliente no confiable, se le permitirá sólo si pasa cualquier
regla aplicable [`allow`](#allow) y [`deny`](#deny).

En el servidor, si no proporciona un <i>callback</i>, entonces `insert` bloquea
que la base de datos reconozca la escritura, o se produzca una excepción si
algo salió mal.  Si  proporciona un <i>callback</i>, `insert` sigue devolviendo 
el ID de inmediato. Una vez que la inserción se completa (o falla),
el <i>callback</i> es llamado con argumentos de error y resultado.  En caso de error,
`result` es indefinido.  Si la insercion tiene éxito, `error` es
indefinido y `result` es el nuevo ID de documento.

En el cliente, `insert` nunca bloquea.  Si usted no provee un <i>callback</i>
y la inserción falla en el servidor, entonces Meteor registrará un <i>warning</i> en
la consola.  Si  provee un <i>callback</i>, Meteor llamará esa función con argumentos
`error` y `result`. En caso de error, `result` es indefinido.  
Si la inserción tiene éxito, `error` es indefinido y `result` es el nuevo ID de documento.

Ejemplo:

    var groceriesId = Lists.insert({name: "Groceries"});
    Items.insert({list: groceriesId, name: "Watercress"});
    Items.insert({list: groceriesId, name: "Persimmons"});

{{> api_box update}}

Modificar documentos que coinciden con `selector` según `modifier` (Ver
[modifier documentation](#modifiers)).

El comportamiento de `update` difiere dependiendo de si se es llamado por 
código confiable o código no confiable. Código confiable incluye código 
del servidor y código de método. Código no confiable incluye código <i>client-side</i>
tales como controladores de eventos y un navegador con consola JavaScript.

- El código confiable puede modificar varios documentos a la vez estableciendo
  `multi` a <i>true</i>, y puede utilizar un arbitrario [Mongo
  selector](#selectors) para encontrar los documentos que desee modificar. 
  Se pasan por alto las reglas de control de acceso establecidos por
  [`allow`](#allow) y [`deny`](#deny).

- El código no confiable sólo puede modificar un documento único a la vez, especificado 
  por sus `_id`. La modificación se permite sólo después de comprobar cualquier
  regla aplicable [`allow`](#allow) y [`deny`](#deny).

En el servidor, si usted no proporciona un <i>callback</i>,, entonces `update` se bloquea
hasta que la base de datos reconoce la escritura, o lanza una excepción si algo salió mal.
Si usted proporciona un <i>callback</i>, `update` retorna immediatamente.  
Una vez finalizada la actualización, el <i>callback</i> se llama con un único argumento de error en
el caso de fallo, o sin argumentos si la actualización se ha realizado correctamente.

En el cliente, `update` nunca bloquea.  Si usted no provee un <i>callback</i>
y la actualización falla en el servidor, entonces Meteor registrará un <i>warning</i> en
la consola.  Si  provee un <i>callback</i>,  Meteor llamará esa función con 
un argumento error si hubiera un error, o sin argumentos si la actualización tuvo éxito.

Ejemplo en cliente:

    // Cuando el botón <i>givePoints</i> en el <i>dashboard</i> de administración es pulsado,
    // aumenta 5 puntos al jugador actual. La nueva puntuación será
    // inmediatamente visible en las pantallas de todo el mundo.
    Template.adminDashboard.events({
      'click .givePoints': function () {
        Players.update(Session.get("currentPlayer"), {$inc: {score: 5}});
      }
    });

Ejemplo de servidor:

    // Dar la tarjeta "Winner" a cada usuario con una puntuación superior a 
    // 10. Si está conectado y su lista de tarjeras está visible en
    // pantalla, se actualizará automáticamente mientras se está viendo.
    Meteor.methods({
      declareWinners: function () {
        Players.update({score: {$gt: 10}},
                       {$addToSet: {badges: "Winner"}},
                       {multi: true});
      }
    });

{{#warning}}
La característica Mongo `upsert` no está implementada.
{{/warning}}

{{> api_box remove}}

Encuentra todos los documentos que coinciden con `selector` y los elimina de la colección.

El comportamiento de `remove` difiere dependiendo de si se es llamado por
código confiable o no confiable. Código confiable incluye código 
de servidor y código de método. Código no confiable incluye código <i>client-side</i>
tales como controladores de eventos y un navegador con consola JavaScript.

- El código confiable puede utilizr un arbitrario [Mongo selector](#selectors)
  para encontrar los documentos que desea eliminar, y puede eliminar más de un documento
  a la vez pasando un selector con el que coincidan multiples documentos.
  Se pasan por alto las reglas de control de acceso establecidos por  
  [`allow`](#allow) y [`deny`](#deny).

  Como medida de seguridad, si se omite `selector` (o es `undefined`),
  ningún documento será eliminado. Establezca `selector` a `{}` si realmente desea
  eliminar todos los documentos de su colección.

- El código no confiable sólo puede eliminar un documento único a la vez, especificado 
  por sus `_id`. El documento es eliminado sólo después de comprobar cualquier
  regla aplicable [`allow`](#allow) y [`deny`](#deny).
  
En el servidor, si usted no proporciona un <i>callback</i>, entonces `update` se bloquea
hasta que la base de datos reconoce la escritura, o lanza una excepción si algo salió mal.
Si usted proporciona un <i>callback</i>, `update` retorna immediatamente.  
Una vez finalizada la actualización, el <i>callback</i> se llama con un único argumento de error en
el caso de avería, o sin argumentos si la actualización se ha realizado correctamente.

En el servidor, si usted no proporciona un <i>callback</i>, entonces `remove` se bloquea
hasta que la base de datos reconoce la escritura, o lanza una excepción si algo salió mal.
Si usted proporciona un <i>callback</i>, `remove` retorna immediatamente.  
Una vez completado el borrado, the <i>callback</i> se llama con un único argumento de error en
el caso de error, o sin argumentos si el borrado se ha realizado correctamente.

En el cliente, `remove` nunca se bloquea.  Si usted no provee un <i>callback</i>
y el borrado falla en el servidor, entonces Meteor registrará un <i>warning</i> en
la consola.  Si  provee un <i>callback</i>,  Meteor llamará esa función con 
un argumento error si hubiera un error, o sin argumentos si el borrado tuvo éxito.

Ejemplo en cliente:

    // Cuando el botón de borrado es clicado en un mensage de chat, elimina
    // ese mensage.
    Template.chat.events({
      'click .remove': function () {
        Messages.remove(this._id);
      }
    });

Ejemplo de servidor:

    // Cuando el servidor comienza, limpia el <i>log</i>, y eliminar a todos los <i>players</i>
    // con un karma menor que -2.
    Meteor.startup(function () {
      if (Meteor.isServer) {
        Logs.remove({});
        Players.remove({karma: {$lt: -2}});
      }
    });

{{> api_box allow}}

Cuando un cliente llama `insert`, `update`, o `remove` en una colección, los
<i>callbacks</i> de las colecciones `allow` y [`deny`](#deny) se invocan en el
servidor para determinar si la escritura se debe permitir. Si al menos
un <i>callback</i> `allow` permite la escritura, y ningún <i>callback</i> `deny` niega la
escritura, entonces, se permite proceder con la escritura.

Estos controles se realizan sólo cuando un cliente intenta escribir en 
la base de datos directamente, por ejemplo llamando `update` desde el interior 
de un controlador de eventos. El código de servidor es confiable y no está 
sujeto a las restrictions `allow` y `deny`. Que incluye métodos que son llamados con
`Meteor.call` &mdash; que se espera que hagan su propio control de acceso en lugar 
de depender de `allow` y `deny`.

Usted puede llamar `allow` tantas veces como quiera,  y cada llamada
puede incluir cualquier combinación de las funciones `insert`, `update`, y `remove`. 
Las funciones deben devolver `true` si piensan que la operación se debe permitir. 
De lo contrario, debe devolver `false`, o nada en absoluto (`undefined`). 
En ese caso Meteor continuará buscando a través de cualquier otra regla de 
la colección.

Los <i>callbacks</i> disponibles son:

<dl class="<i>callbacks</i>">
{{#dtdd "insert(userId, doc)"}}
El usuario `userId` quiere insertar el documento `doc` en la
colección. Retorna `true` si esto ha de estar permitido.
{{/dtdd}}

{{#dtdd "update(userId, doc, fieldNames, modifier)"}}

El usuario `userId` quiere actualizar un documento `doc`. (`doc` es la
versión actual del documento desde la base de datos, sin la actualización 
propuesta.) Devuelve `true` para permitir el cambio.

`fieldNames` es un array de los campos (top-level) en `doc` que el cliente 
quiere modificar, por ejemplo
`['name',`&nbsp;`'score']`. `modifier` es el modificador <i>raw Mongo</i> que
el cliente quiere ejecutar, por ejemplo `{$set: {'name.first':
"Alice"}, $inc: {score: 1}}`.

Sólo los modificadores Mongo están soportados (operaciones como `$set` y `$push`).
Si el usuario intenta reemplazar el documento completo en lugar de usar
$-modifiers, la solicitud será denegada sin comprobar las funciones `allow`.

{{/dtdd}}

{{#dtdd "remove(userId, doc)"}}

El usuario `userId` quiere borrar `doc` de la base de datos. Retorna
`true` para permitir esto.

{{/dtdd}}

</dl>

Cuando se llama `update` o `remove` Meteor por defecto extraerá el
documento completo  `doc` de la base de datos. Si tiene documentos de gran tamaño
podría desear extraer sólo los campos que sean realmente utilizadas por sus
funciones. Lograr esto mediante el establecimiento de `fetch` a un array de nombres
de campos por recuperar.

Ejemplo:

    // Crea una colección donde los usuarios sólo puedan modificar documentos que
    // que poseen.  La propiedad es rastreada por un campo 'owner' en cada
    // documento. Todos los documentos deben ser propiedad del usuario que los creó
    // y la propiedad no se puede cambiar. Sólo el propietario de un documento
    // tiene permiso para eliminarlo, y el atributo 'locked'  se puede
    // establecer en un documento para evitar su borrado accidental.

    Posts = new Meteor.Collection("posts");

    Posts.allow({
      insert: function (userId, doc) {
        // El usuario debe estar registrado, y el documento debe ser propiedad del usuario
        return (userId && doc.owner === userId);
      },
      update: function (userId, doc, fields, modifier) {
        // sólo puede cambiar sus propios documentos
        return doc.owner === userId;
      },
      remove: function (userId, doc) {
        // sólo puede cambiar sus propios documentos
        return doc.owner === userId;
      },
      fetch: ['owner']
    });

    Posts.deny({
      update: function (userId, docs, fields, modifier) {
        // no se puede cambiar de propietario
        return _.contains(fields, 'owner');
      },
      remove: function (userId, doc) {
        // no se puede eliminar documentos bloqueados
        return doc.locked;
      },
      fetch: ['locked'] // no hay necesidad de buscar "propietario"
    });

Si nunca establece ninguna regla `allow` en una colección entonces que 
cualquier cliente escriba en la colección se puede denegar, y sólo será posible 
escribir en la colección con código del lado del servidor <i>server-side</i>. 
En este caso, usted tendrá que crear un método para cada escritura posible que 
los clientes tengan permitido hacer. Por consiguiente, llame a estos métodos con 
`Meteor.call` en lugar de que los clientes llamen a `insert`, `update`, 
y `remove` directamente en la colección.

Meteor también tiene un especial "insecure mode" para el rápido prototipado 
de nuevas aplicaciones. En el modo no seguro, si no se ha establecido ninguna
regla `allow` o `deny` en una colección entonces todos lo usuarios tienen pleno
acceso de escritura en la colección. Este es el único efecto del modo no seguro. Si llama `allow` o
`deny` en todo en una colección, incluso `Posts.allow({})`, entonces el acceso 
se comprueba justo de manera normal en esa colección.
__Los nuevos projectos Meteor se inician en modo inseguro
 por defecto.__ Para desactivarlo basta con ejecutar `$ meteor remove insecure`.

{{> api_box deny}}

Esto funciona igual que [`allow`](#allow), excepto que le permite asegurarse de
que ciertas escrituras son definitivamente denegadas, incluso si hay una regla
`allow`  que dice que se debe permitir. Cuando un cliente intenta
escribir en una colección, el servidor comprueba primero las reglas `deny` 
de la colección. Si ninguna de ellas retorna <i>true</i> entonces se comprueban
reglas `allow` de la colección. Meteor permite la escritura sólo si no hay
reglas `deny` retorna `true` y al menos una regla `allow` retorna `true`.

<h2 id="meteor_collection_cursor"><span>Cursors</span></h2>

Para crear un cursor, utilice [`find`](#find).  Para acceder a los documentos en un
cursor, utilice [`forEach`](#foreach), [`map`](#map), o [`fetch`](#fetch).

{{> api_box cursor_foreach}}

Cuando se llama desde una computación reactiva, `forEach` registra las dependencias 
de los documentos coincidentes.

Ejemplos:

    // Imprime los títulos de las cinco mensajes de puntuación superior
    var topPosts = Posts.find({}, {sort: {score: -1}, limit: 5});
    var count = 0;
    topPosts.forEach(function (post) {
      console.log("Title of post " + count + ": " + post.title);
      count += 1;
    });

{{> api_box cursor_map}}

Cuando se llama desde una computación reactiva, `map` registra las dependencias 
de los documentos coincidentes.

<!-- Lo siguiente no se ha implementado todavía, pero los usuarios no deben asumir
ejecución secuencial de todos modos porque fallará. -->
En el servidor, si, `<i>callback</i>` cede, otras llamadas `<i>callback</i>` pueden ocurrir mientras 
la primera llamada está esperando. Si una estricta ejecución secuencial es necesaria, 
use `foreach` en su lugar.

{{> api_box cursor_fetch}}

Cuando se llama desde una computación reactiva, `fetch` registra las dependencias 
de los documentos coincidentes.

{{> api_box cursor_count}}

    // Muestra un recuento de los mensajes que coincidan con determinados criterios. 
    //Automaticamente  lo mantiene actualizado con los cambios de la base de datos.
    var frag = Meteor.render(function () {
      var highScoring = Posts.find({score: {$gt: 10}});
      return "<p>There are " + highScoring.count() + " posts with " +
        "scores greater than 10</p>";
    });
    document.body.appendChild(frag);

A diferencia de las otras funciones, `count` registra una dependencia sólo 
del número de documentos que coinciden. Las actualizaciones que acaban de cambiar
o reordenar los documentos en el conjunto de resultados no dará lugar a un 
recálculo.)

{{> api_box cursor_rewind}}

Los métodos `forEach`, `map`, or `fetch`  sólo pueden ser llamados una vez en un
cursor. Para acceder a los datos en un cursor más de una vez, utilice 
 `rewind` para restablecer el cursor.

{{> api_box cursor_observe}}

Establecer un *live query* que invoca <i>callbacks</i> cuando el resultado de la 
consulta cambia. Los <i>callbacks</i> reciben todo el contenido del documento que 
fue afectado, así como su contenido anterior, si procede. Si sólo necesita recibir
los campos que han cambiado, ver [`observeChanges`](#observe_changes).

Los `<i>callbacks</i>` pueden tener las siguientes funciones como propiedades: 


<dl class="<i>callbacks</i>">
<dt><span class="name">added(document)</span> <span class="or">or</span></dt>
<dt><span class="name">addedAt(document, atIndex, before)</span></dt>
<dd>
{{#better_markdown}}
Un nuevo documento `document` ha entrado en el conjunto de resultados. 
El nuevo documento aparece en la posición `atIndex`. inmediatamente antes 
del documento cuya `_id` es `before`. `before` será `null` si el nuevo documento 
está al final de los resultados. 

{{/better_markdown}}
</dd>

<dt><span class="name">changed(newDocument, oldDocument)
    <span class="or">or</span></span></dt>
<dt><span class="name">changedAt(newDocument, oldDocument, atIndex)</span></dt>
<dd>
{{#better_markdown}}
El contenido de un documento previamente era `oldDocument` y ahora es 
`newDocument`.  La posición del documento cambiado es `atIndex`.
{{/better_markdown}}
</dd>

<dt><span class="name">removed(oldDocument)</span>
  <span class="or">or</span></dt>
<dt><span class="name">removedAt(oldDocument, atIndex)</span></dt>
<dd>
{{#better_markdown}}
El documento `oldDocument` deja de estar en el conjunto de resultados.
Lo que antes era la posición `atIndex`.
{{/better_markdown}}
</dd>

{{#dtdd "movedTo(document, fromIndex, toIndex, before)"}}
Un documento se cambia de posición en el conjunto de resultados, de
 `fromIndex` a `toIndex`
(Que está antes del documento con id  `before`). Sus contenido actual es
`document`.
{{/dtdd}}
</dl>

Utilice `added`, `changed`, y `removed` cuando no le preocupe el orden de 
los documentos en el conjunto de resultados. Estos son más eficientes que 
`addedAt`, `changedAt`, y `removedAt`.

Antes de retornos `observe`, `added` (o `addedAt`) será llamado cero
o más veces para entregar los primeros resultados de la consulta.

`observe` retorna un manejador de consulta en vivo, que es un objeto con un 
método `stop`.
Llamar `stop` sin argumentos detiene la llamada a las funciones <i>callback</i>  
y desmonta la consulta. **La consulta se ejecutará para siempre hasta que usted 
llame esto.** Si `observe`  se llama desde un cómputo `Deps.autorun`, se detiene 
automáticamente cuando la computación se vuelve a ejecutar o es reejecutado o detenido.
(Si el cursor se creó con la opción `reactive` establecido en <i>false</i>, 
sólo proporcionará los resultados iniciales y no llamará a ningún adicional <i>callbacks</i>;
no es necesario llamar `stop` en el manejador.)


{{> api_box cursor_observe_changes}}

Establece un *live query* que invoca <i>callbacks</i> cuando el resultado 
de la consulta cambia. En contraste con [`observe`](#observe),
`observeChanges` que proporciona sólo la diferencia entre el conjunto de 
resultados antiguos y nuevos, no todo el contenido del documento que ha cambiado.

Los `<i>callbacks</i>` pueden tener las siguientes funciones como propiedades:


<dl class="callbacks">
<dt><span class="name">added(id, fields)</span>
  <span class="or">or</span></dt>
<dt><span class="name">addedBefore(id, fields, before)</span></dt>
<dd>
{{#better_markdown}}
Un nuevo documento entró en el conjunto de resultados. Tiene
el `id` y `fields` especificados. Contiene todos los campos del
documento excluyendo el campo `_id`. El nuevo documento es anterior al
documento identificado por `before`, o el último si `before` es `null`.
{{/better_markdown}}
</dd>

{{#dtdd "changed(id, fields)"}}
El documento identificado por `id` ha cambiado. `fields` contiene los campos 
modificados con sus nuevos valores. Si un campo se eliminó del documento entonces,
éste estará presente en `fields` con un valor `undefined`.
{{/dtdd}}

{{#dtdd "movedBefore(id, before)"}}
El documento identificado por `id` ha cambiado su posición en el orden del conjunto 
de resultados, y ahora aparece antes del documento identificado por `before`.
{{/dtdd}}

{{#dtdd "removed(id)"}}
El documento identificado por `id` se eliminó del conjunto de resultados.
{{/dtdd}}
</dl>

`observeChanges` es mucho más eficiente si no se utiliza
`addedBefore` o `movedBefore`.

Antes de que `observeChanges` devuelva, `added` (o `addedBefore`) se llamará
cero o más veces para proporcionar los resultados iniciales de la consulta.

`observeChanges` devuelve un manejador de consulta en vivo, que es un objeto con un
método `stop`.
Llamar `stop` sin argumentos detiene las llamadas de las funciones <i>callback</i> 
y desmonta la consulta. **La consulta se ejecutará para siempre hasta que se llama esto.**
Si `observeChanges` es llamado desde un cómputo `Deps.autorun`,  se detiene 
automáticamente cuando la computación se vuelve a ejecutar o es detenido.
(Si el cursor fué creado con la opción `reactive` establecida en <i>false</i>, 
sólo proporcionará los resultados iniciales y no llama a ningún adicional <i>callbacks</i>;
no es necesario llamar `stop` en el manejador.)

{{#note}}
A diferencia de `observe`, `observeChanges` no proporciona información de la posición 
absoluta. (eso es, la posición `atIndex` en vez de la posición `before`.) Esto es por 
eficiencia.
{{/note}}

Ejemplo:

    //Mantener un seguimiento de cuántos administradores hay online.
    var count = 0;
    var query = Users.find({admin: true, onlineNow: true});
    var handle = query.observeChanges({
      added: function (id, user) {
        count++;
        console.log(user.name + " brings the total to " + count + " admins.");
      },
      removed: function () {
        count--;
        console.log("Lost one. We're now down to " + count + " admins.");
      }
    });

    // Después de cinco segundos, deja de mantener el recuento.
    setTimeout(function () {handle.stop();}, 5000);

{{> api_box collection_object_id}}

`Meteor.Collection.ObjectID` sigue la misma API que el [Node MongoDB driver
`ObjectID`](http://mongodb.github.com/node-mongodb-native/api-bson-generated/objectid.html)
class. Tenga en cuenta que debe utilizar el método `equals`  (o [`EJSON.equals`](#ejson_equals)) para
compararlos; the `===` operator no funcionará. Si va a escribir código genérico que tiene que lidiar 
con campos `_id` que pueden ser cualquier cadena o `ObjectID`s, utilice
[`EJSON.equals`](#ejson_equals) en vez de  `===` para compararlos.

{{#note}}
  Los valores `ObjectID` creados por Meteor no tienen respuestas significativas a su método `getTimestamp`
  ya que actualmente Meteor los construye completamente al azar.
{{/note}}

{{#api_box_inline selectors}}

En su forma más simple, un selector es sólo un conjunto de claves que deben coincidir
en un documento:

    // Coincide con todos los documentos donde eliminado es <i>false</i>
    {deleted: false}

    // Coincide con todos los documentos donde el nombre y apellido son dados.
    {name: "Rhialto", cognomen: "the Marvelous"}

    // Coincide con todos los documentos.
    {}

Pero también puede contener pruebas más complicadas: 

    // Coincide con documentos donde la edad es mayor de 18
    {age: {$gt: 18}}

    // También coincide con documentos donde <i>tags</i> es un <i>array</i> que contiene "popular"
    {tags: "popular"}

    // Coincide con documentos donde fruta es una de tres posibilidades
    {fruit: {$in: ["peach", "plum", "pear"]}}

Ver la [documentación 
 completa](http://www.mongodb.org/display/DOCS/Advanced+Queries).

{{/api_box_inline}}

{{#api_box_inline modifiers}}

 Un modificador es un objeto que describe cómo actualizar un documento 
 en lugar de cambiar algunos de sus campos. 
 Algunos ejemplos:

    // Establece la propiedad 'admin' en el documento a <i>true</i>
    {$set: {admin: true}}

    // Añade 2 a la propiedad 'votes' y añade "Traz"
    // al final del <i>array</i> 'supporters' 
    {$inc: {votes: 2}, $push: {supporters: "Traz"}}

Sin embargo, si un modificador no contiene ningún $-operators, entonces en su lugar 
se interpreta como un documento literal, y reemplaza por completo lo que estaba 
previamente en la base de datos. ( Modificadores literales del documento no están 
actualmente soportados por [validated updates](#allow).)

    // Buscar el documento con id "123", y reemplazarlo completamente.
    Users.update({_id: "123"}, {name: "Alice", friends: ["Bob"]});

Ver la [lista completa de
modificadores](http://www.mongodb.org/display/DOCS/Updating#Updating-ModifierOperations).

{{/api_box_inline}}

{{#api_box_inline sortspecifiers}}

Sorts puede ser specificado usando varias opciones de sintaxis:

    // Todo esto hace la misma cosa  (ordena en orden ascendente por 
    // la clave  "a", rompiendo lazos en orden descendente de la clave "b")

    [["a", "asc"], ["b", "desc"]]
    ["a", ["b", "desc"]]
    {a: 1, b: -1}

La última forma sólo funcionará si su aplicación JavaScript
conserva el orden de las claves en objetos. 
La mayoría lo hacen, la mayoría de
el tiempo, pero depende de usted para estar seguro. 

{{/api_box_inline}}

{{#api_box_inline fieldspecifiers}}

En el servidor, las consultas pueden especificar una determinado conjunto de campos 
para incluir o excluir del objeto resultado. (El especificador de campo se ignora actualmente en el cliente.)

Para excluir ciertos campos de los objetos resultado, el especificador de campo es un
diccionario cuyas claves son los nombres de campos y cuyos valores son  `0`.

    // Users.find({}, {fields: {password: 0, hash: 0}})

 para devolver un objeto que sólo incluye el campo especificado, utilice `1` 
 como valor. El campo `_id` aún se incluye en el resultado.

    // Users.find({}, {fields: {firstname: 1, lastname: 1}})

No es posible mezclar estilos de inclusión y exclusión.

{{/api_box_inline}}

<h2 id="session"><span>Session</span></h2>

`Session` proporciona un objeto global en el cliente que puede utilizar para
almacenar un conjunto arbitrario de pares clave-valor. Utilícelo para almacenar 
cosas como el elemento actualmente seleccionado en una lista.

¿Qué tiene de especial `Session`?  que es reactivo. Si 
llama [`Session.get`](#session_get)`("currentList")`
desde el interior de una plantilla, la plantilla automaticamente se revisualizará
cada vez que se llame [`Session.set`](#session_set)`("currentList", x)`.

{{> api_box set}}

Ejemplo:

    Deps.autorun(function () {
      Meteor.subscribe("chat-history", {room: Session.get("currentRoomId")});
    });

    // Hace que la función pasada a Deps.autorun se reejecute, por lo 
    // que la suscripción de <i>chat-history</i> se mueva a la sala "home".
    Session.set("currentRoomId", "home");

{{> api_box setDefault}}

Esto es útil en el código de inicialización, para evitar volver a inicializar una
variable de sesión cada vez que una nueva versión de su aplicación se cargue.

{{> api_box get}}

Ejemplo:

    Session.set("enemy", "Eastasia");
    var frag = Meteor.render(function () {
      return "<p>We've always been at war with " +
        Session.get("enemy") + "</p>";
    });

    // Page will say "We've always been at war with Eastasia"
    document.body.append(frag);

    // Page will change to say "We've always been at war with Eurasia"
    Session.set("enemy", "Eurasia");

{{> api_box equals}}

Si el valor es un escalar, entonces estas dos expresiones hacen la misma cosa: 

    (1) Session.get("key") === value
    (2) Session.equals("key", value)

... pero el segundo es siempre mejor. Se dispara el menor número de invalidaciones
(Se vuelve a dibujar la plantilla), haciendo su programa más eficiente.

Ejemplo:

    <template name="postsView">
    {{dstache}}! Muestra la actualización dinámica de una lista de elementos. 
     {{! Deje que el usuario haga clic en un elemento para seleccionarlo.
         Al elemento seleccionado se le da una clase CSS para que 
         pueda ser mostrado de manera diferente. }}

    {{dstache}}#each posts}}
      {{dstache}}> postItem }}
    {{dstache}}/each}}
    </{{! }}template>

    <template name="postItem">
      <div class="{{dstache}}postClass}}">{{dstache}}title}}</div>
    </{{! }}template>

    ///// in JS file
    Template.postsView.posts = function() {
      return Posts.find();
    };

    Template.postItem.postClass = function() {
      return Session.equals("selectedPost", this._id) ?
        "selected" : "";
    };

    Template.postItem.events({
      'click': function() {
        Session.set("selectedPost", this._id);
      }
    });

    // El uso de Session.equals aquí significa que cuando el usuario clica
    // en un item y cambia la selección, sólo los <i>items</i> recién seleccionado
    // y el recién deseleccionado son re-visualizados.
    //
    // Si Session.get había sido utilizado en lugar de Session.equals, entonces
    // cuando la selección cambia, todos los items serán revisualizados.

Para los valores de sesión de object y array, no puede utilizar `Session.equals`; en su lugar,
usted necesita utilizar el paquete `underscore` y escribir
`_.isEqual(Session.get(key), value)`.



<h2 id="accounts_api"><span>Accounts</span></h2>
 
El sistema <i>Meteor Accounts</i> construye en la parte superior de `userId` soporte a 
[`publish`](#publish_userId) y [`methods`](#method_userId). Los paquetes principales 
añaden el concepto de documentos usuario almacenado en la base de datos, y
paquetes adicionales añaden [secure password
authentication](#accounts_passwords), [integration with third party
login services](#meteor_loginwithexternalservice), y un [pre-built user
interface](#accountsui).

El básico <i>Accounts system</i> está en el paquete `accounts-base`, pero
las aplicaciones suelen incluir esto automaticamente mediante la adición de uno de los
paquetes proveedores de <i>login</i>: `accounts-password`, `accounts-facebook`,
`accounts-github`, `accounts-google`, `accounts-meetup`,
`accounts-twitter`, or `accounts-weibo`.


{{> api_box user}}

Recupera el registro de usuario para el usuario actual desde
la colección [`Meteor.users`](#meteor_users).

En el cliente, este será el subconjunto de los campos en el documento que
se publica en el servidor (otros campos no estarán disponibles en el
cliente). Por defecto, el servidor publica `username`, `emails`, y
`profile`. Ver [`Meteor.users`](#meteor_users) para más información sobre
los campos utilizados en los documentos del usuario.

{{> api_box userId}}

{{> api_box users}}

Esta colección contiene un documento por usuario registrado. Aquí hay un ejemplo:
documento de usuario:

    {
      _id: "bbca5d6a-2156-41c4-89da-0329e8c99a4f",  // Meteor.userId()
      username: "cool_kid_13", // unique name
      emails: [
        // cada dirección de correo electrónico sólo puede pertenecer a un usuario
        { address: "cool@Ejemplo.com", verified: true },
        { address: "another@different.com", verified: false }
      ],
      createdAt: 1349761684042,
      profile: {
        //  El perfil puede ser escrito por el usuario de forma predeterminada.
        name: "Joe Schmoe"
      },
      services: {
        facebook: {
          id: "709050", // facebook id
          accessToken: "AAACCgdX7G2...AbV9AZDZD"
        },
        resume: {
          loginTokens: [
            { token: "97e8c205-c7e4-47c9-9bea-8e2ccc0694cd",
              when: 1349761684048 }
          ]
        }
      }
    }

Un documento de usuario puede contener cualquier dato que desee guardar sobre un usuario.
Meteor trata los siguientes campos especialmente:

- `username`: un único <i>String</i> que identifica el usuario.
- `emails`: un <i>Array</i> de <i>Objects</i> con claves `address` y `verified`;
  una dirección <i>email</i> puede pertenecer a más de un usuario.  `verified` es
  un <i>Boolean</i> que es <i>true</i> si el usuario ha [verificado la
  dirección](#accounts_verifyemail) con una señal enviada a través de correo electrónico.
- `createdAt`: un <i>timestamp</i> numérico (milisegundos desde el 1 de Enero de 1970)
   del momento cuando el usuario  ha creado el documento.
- `profile`: un <i>Object</i> que (por defecto) el usuario puede crear
  y actualizar con los datos.
- `services`: un <i>Object</i> que contiene los datos utilizados por los servicios de login 
  en particular. Por Ejemplo, su campo `reset` contiene
  fichas utilizadas por enlaces [forgot password](#accounts_forgotpassword),
  y su campo `resume` contiene fichas utilizadas para mantenerle 
  conectado entre sesiones.

Igual que todas las colecciones [Meteor.Collection](#collections)s, usted puede acceder a todos 
los documentos en el servidor, pero sólo aquellos específicamente publicados por el servidor
están accesibles en el cliente.

Por defecto, el usuario actual `username`, `emails` y `profile` 
se publican en el cliente. Puede publicar campos adicionales para el
 usuario actual con:

    Meteor.publish("userData", function () {
      return Meteor.users.find({_id: this.userId},
                               {fields: {'other': 1, 'things': 1}});
    });

Si el paquete `autopublish` está instalado, los campos `username` y `profile`
de todos los usuarios se publican para todos los clientes. Para publicar campos 
específicos de todos los usuarios:

    Meteor.publish("allUserData", function () {
      return Meteor.users.find({}, {fields: {'nested.things': 1}});
    });

A los usuarios, por defecto se les permite especificar su propio campo `profile` con
[`Accounts.createUser`](#accounts_createuser) y  modificarlo con
`Meteor.users.update`. Para permitir a los usuarios editar campos adicionales, utilice
[`Meteor.users.allow`](#allow). Para prohibir a los usuarios que realicen cualquier modificación
en su documento de usuario :

    Meteor.users.deny({update: function () { return true; }});


{{> api_box loggingIn}}

Por Ejemplo, [the `accounts-ui` package](#accountsui) utiliza esta opción para mostrar una
animación mientras que la solicitud de acceso se está procesando.

{{> api_box logout}}

{{> api_box loginWithPassword}}

Esta función está proporcionada por el paquete `accounts-password`. Ver el
[Passwords](#accounts_passwords) en la sección siguiente.


{{> api_box loginWithExternalService}}

Estas funciones inician el proceso de <i>login</i> con un servicio externo
(ej: Facebook, Google, etc), utilizando<i> OAuth</i>. Cuándo se invocan abren una nueva ventana pop-up
que carga la página de <i>login</i> del proveedor. Una vez que el usuario ha iniciado la sesión 
con el proveedor, la ventana pop-up se cierra y el cliente Meteor se inicia en el servidor Meteor
con información proporcionada por el servicio externo.

<a id="requestpermissions" name="requestpermissions" />

Además de identificar al usuario en su aplicación, algunos servicios 
tienen APIs que le permiten actuar en nombre del usuario. Para 
solicitar permisos específicos del usuario, pase la opción 
`requestPermissions` a la función <i>login</i>. Esto causará que el usuario
sea presentado con una página adicional en el <i>pop-up</i> dialogo para permitir
el acceso a sus datos. El usuario `accessToken` &mdash; con permisos
de acceso a los servicios API &mdash; es guardado en el campo `services` del
documento del usuario. Los valores admitidos por `requestPermissions` son diferentes
para cada servicio de <i>login</i>  y están documentados sus respectivos sitios para 
desarrolladores:

- Facebook: <http://developers.facebook.com/docs/authentication/permissions/>
- GitHub: <http://developer.github.com/v3/oauth/#scopes>
- Google: <https://developers.google.com/accounts/docs/OAuth2Login#scopeparameter>
- Meetup: <http://www.meetup.com/meetup_api/auth/#oauth2-scopes>
- Twitter, Weibo: `requestPermissions` actualmente no suportado

Los servicios de acceso externos suelen requerir registro y configuración
en su aplicación antes del uso.  La manera más fácil de hacerlo es con el
[`accounts-ui` package](#accountsui) que presenta una guía paso a paso
al configurar cada servicio. Sin embargo, los datos pueden también ser introducidos
manualmente en la colección `Accounts.loginServiceConfiguration`. 

Por Ejemplo:

    // Primero, borre la configuración de entrada en el caso de que el servicio ya esté configurado
    Accounts.loginServiceConfiguration.remove({
      service: "weibo"
    });
    Accounts.loginServiceConfiguration.insert({
      service: "weibo",
      clientId: "1292962797",
      secret: "75a730b58f5691de5522789070c319bc"
    });


Cada servicio externo tiene su propio paquete de proveedor de <i>login</i> y función de <i>login</i>
Por ejemplo, para respaldar el <i>login GitHub</i>, ejecute `$ meteor add accounts-github` y utilice la
función `Meteor.loginWithGithub` :

    Meteor.loginWithGithub({
      requestPermissions: ['user', 'public_repo']
    }, function (err) {
      if (err)
        Session.set('errorMessage', err.reason || 'Unknown error');
    });


{{> api_box currentUser}}
{{> api_box loggingInTemplate}}
{{> api_box accounts_config}}
{{> api_box accounts_ui_config}}

Ejemplo:

    Accounts.ui.config({
      requestPermissions: {
        facebook: ['user_likes'],
        github: ['user', 'repo']
      },
      requestOfflineToken: {
        google: true
      },
      passwordSignupFields: 'USERNAME_AND_OPTIONAL_EMAIL'
    });

{{> api_box accounts_validateNewUser}}

Esto puede ser llamado multiple veces. Si alguna de las funciones devuelve `false` o
lanza un error, la creación de nuevo usuario se interrumpe. Para establecer un específico 
mensage de error (que será visualizado por [`accounts-ui`](#accountsui)), al lanzar un nuevo
[`Meteor.Error`](#meteor_error).

Ejemplo:

    // Validar nombre de usuario, envía un mensaje de error específico en caso de fallo.
    Accounts.validateNewUser(function (user) {
      if (user.username && user.username.length >= 3)
        return true;
      throw new Meteor.Error(403, "Username must have at least 3 characters");
    });
    // Valida nombre de usuario, sin un mensaje de error específico.
    Accounts.validateNewUser(function (user) {
      return user.username !== "root";
    });

{{> api_box accounts_onCreateUser}}

Utilice esta opción cuando necesite hacer algo más que simplemente aceptar o rechazar 
la creación del nuevo usuario. Con esta función puede controlar mediante programación 
el contenido del nuevo documento de usuario.

La función que pase será llamada con dos argumentos: `options` y `user`. El argumento `options` viene
de [`Accounts.createUser`](#accounts_createuser) para usuarios basados ​​en contraseñas o de un flujo 
de servicio de acceso externo. `options` puede provenir de un cliente no confiable así que asegúrese 
de validar cualquier valor que lea de la misma.

El argumento `user` se crea en el servidor y contiene un propuesto objeto usuario
con todos los campos generados automáticamente requeridos por el usuario para iniciar sesión.

La función debe devolver el documento de usuario (ya sea de uno pasado o a
un objeto recién creado) con cualquier modificación que se desee. El documento devuelto
se inserta directamente en la colección [`Meteor.users`](#meteor_users).

La función para crear usuario por defecto simplemene copia `options.profile` en
el nuevo documento de usuario. Llamando `onCreateUser` reemplaza el enganche por defecto.
Esto sólo puede ser llamado una vez.

Ejemplo:

<!-- XXX replace d6 with _.random once we have underscore 1.4.2 -->

    // Support for playing D&D: Roll 3d6 for dexterity
    Accounts.onCreateUser(function(options, user) {
      var d6 = function () { return Math.floor(Random.fraction() * 6) + 1; };
      user.dexterity = d6() + d6() + d6();
      // We still want the default hook's 'profile' behavior.
      if (options.profile)
        user.profile = options.profile;
      return user;
    });


<h2 id="accounts_passwords"><span>Passwords</span></h2>

El paquete  `accounts-password` contiene un sistema completo para autenticación basado en contraseña.
Además del proceso básico Nombre de usuario e inicio de sesión basado en contraseña, también soporta
inicio de sesión basado en email incluyendo verificación de direcciones y recuperación de contraseña 
por <i>email</i>.

A diferencia de la mayoría de aplicaciones web, el cliente Meteor no envía 
la contraseña del usuario directamente al servidor. Se utiliza el [Secure Remote Password
protocol](http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol)
para garantizar que el servidor nunca ve la contraseña del usuario en texto plano. Esto
ayuda a proteger contra fugas embarazosas de contraseñas si la base de datos del servidor
se ve comprometida.

Para agregar soporte de contraseña a su aplicación, ejecute `$ meteor add
accounts-password`. Usted puede construir su propio interfaz de usuario utilizando
las funciones de abajo, o utilizar el [`accounts-ui` package](#accountsui) para
incluir una llave en la interfaz de usuario para un registro basado en contraseña.

{{> api_box accounts_createUser}}

Esta función inicia la sesión como el nuevo usuario creado  que
a finalizdo con éxito. En el servidor, devuelve el <i>id</i> del nuevo usuario creado.

En el cliente, debe pasar  `password` y un `username` o `email`
&mdash; información suficiente para que el usuario pueda acceder de nuevo más 
tarde. En el servidor, puede pasar cualquier subconjunto de estas opciones, pero el
usuario no será capaz de iniciar sesión hasta que tenga un identificador y una contraseña.

Para crear una cuenta sin contraseña en el servidor y todavía permitir al
usuario elegir su propia contraseña, llame `createUser` con la opción `email` 
y luego llame [`Accounts.sendEnrollmentEmail`](#accounts_sendenrollmentemail). Esto
enviará al usuario un correo electrónico con un enlace para establecer su contraseña inicial.

Por defecto la opción `profile`  se añade directamente al nuevo documento de usuario. Para
invalidar este comportamiento utilice [`Accounts.onCreateUser`](#accounts_oncreateuser).

Esta función sólo se utiliza para crear usuarios con contraseñas. 

{{> api_box accounts_changePassword}}

{{> api_box accounts_forgotPassword}}

Esto desencadena una llamada a [`Accounts.sendResetPasswordEmail`](#accounts_sendresetpasswordemail)
en el servidor. Pasa el testigo que el usuario recibirá en este correo electrónico 
a [`Accounts.resetPassword`](#accounts_resetpassword) para completar el proceso de restablecimiento 
de contraseña.

Si está utilizando el [`accounts-ui` package](#accountsui), esto se maneja de forma automática.
De lo contrario, es su responsibilidad solicitar al usuario la 
nueva contraseña y llame `resetPassword`.

{{> api_box accounts_resetPassword}}

Esta función acepta <i>tokens</i> generadas 
por [`Accounts.sendResetPasswordEmail`](#accounts_sendresetpasswordemail)
y
[`Accounts.sendEnrollmentEmail`](#accounts_sendenrollmentemail).

{{> api_box accounts_setPassword}}

{{> api_box accounts_verifyEmail}}

Esta función acepta <i>tokens</i> generadas 
por [`Accounts.sendVerificationEmail`](#accounts_sendverificationemail). Lo
establece en el campo `emails.verified` en el registro de usuario.

{{> api_box accounts_sendResetPasswordEmail}}

El <i>token</i> en este email debe ser pasado
a [`Accounts.resetPassword`](#accounts_resetpassword).

Para personalizar el contenido del correo electrónico, Ver
[`Accounts.emailTemplates`](#accounts_emailtemplates).

{{> api_box accounts_sendEnrollmentEmail}}

El <i>token</i> en este email debe ser pasado
a [`Accounts.resetPassword`](#accounts_resetpassword).

Para personalizar el contenido del correo electrónico, Ver
[`Accounts.emailTemplates`](#accounts_emailtemplates).

{{> api_box accounts_sendVerificationEmail}}

El <i>token</i> en este email debe ser pasado
a [`Accounts.verifyEmail`](#accounts_verifyemail).

Para personalizar el contenido del correo electrónico, Ver
[`Accounts.emailTemplates`](#accounts_emailtemplates).

{{> api_box accounts_emailTemplates}}

Este es un `Object` con varios campos se utilizan para generar texto 
para los <i>emails</i> enviados por `sendResetPasswordEmail`, `sendEnrollmentEmail`,
y `sendVerificationEmail`.

Reemplazar los campos del objeto asignandolos:

- `from`: Un `String` con un [RFC5322](http://tools.ietf.org/html/rfc5322) Dirección del 
   remitente. Por defecto, el <i>email</i> se envía desde `no-reply@meteor.com`. Si usted 
   desea recibir <i>email</i> de los usuarios que solicitan ayuda con su cuenta,
    asegúrese de establecer este a una dirección de <i>email</i> en el que puede recibir correos.
- `siteName`: el nombre público de su aplicación. El valor predeterminado es el nombre DNS de
   la aplicación (eg: `awesome.meteor.com`).
- `resetPassword`: Un `Object` con dos campos:
 - `resetPassword.subject`: Una `Function` que toma un objeto usuario y retorna
   un `String` para la línea de asunto de un restablecimiento <i>email</i> de contraseña.
 - `resetPassword.text`: Una `Function` que toma un objeto usuario y una <i>url</i>, y
   devuelve el cuerpo de texto para restablecer el <i>password</i> por <i>email</i>.
- `enrollAccount`: Igual que `resetPassword`, pero para contraseña inicial al configurar 
   nuevas cuentas.
- `verifyEmail`: Igual que `resetPassword`, pero para verificar la dirección de correo 
electrónico del usuario.


Ejemplo:

    Accounts.emailTemplates.siteName = "AwesomeSite";
    Accounts.emailTemplates.from = "AwesomeSite Admin <accounts@Ejemplo.com>";
    Accounts.emailTemplates.enrollAccount.subject = function (user) {
        return "Welcome to Awesome Town, " + user.profile.name;
    };
    Accounts.emailTemplates.enrollAccount.text = function (user, url) {
       return "You have been selected to participate in building a better future!"
         + " To activate your account, simply click the link below:\n\n"
         + url;
    };


<h2 id="templates_api"><span>Templates</span></h2>

Una plantilla que se declara como `<{{! }}template name="foo"> ... </{{!
}}template>` Puede ser accedida como la función `Template.foo`, que
devuelve una cadena de HTML cuando es llamada.

La misma plantilla puede ocurrir muchas veces en la página, y
estos sucesos se denominan instancias de plantilla.  Las Instancias de la plantilla tienen un
ciclo de vida de creación, colocada en el documento, extraida del documento y destruida.
Meteor gestiona estas etapas por usted, incluyendo la determinación de cuando una instancia de 
plantilla ha sido eliminada o sustituida y debe ser limpiada
Usted puede asociar datos a una instancia de plantilla,
y se puede acceder a los nodos DOM cuando se encuentra en el documento.

Además, Meteor mantendrá una instancia de plantilla y su estado
incluso si su código HTML circundante se vuelve a representar en los nuevos nodos DOM.  
Como siempre  la estructura de invocaciones de plantilla es la misma,
Meteor no tendrá en cuenta todas las instancias que han sido creadas o destruidas.
Puede solicitar que los mismos nodos DOM deban conservarse,
utilizando `preserve` y `constant`.

Hay una serie de <i>callbacks</i> y directivas que puede especificar en 
una plantilla nombrada y que se aplique en todas las instancias 
de la plantilla.
Se describen a continuación. 

{{> api_box template_call}}

Cuando se llama el interior de un auxiliar de plantilla, el cuerpo de `Meteor.render`,
u otros lugares donde HTML reactivo se está generando, el HTML que resulta
es anotado para que sea visualizado como elementos DOM reactivos.
De lo contrario, el HTML es sobrio y estático.

{{> api_box template_rendered}}

Este <i>callback</i> se llama una vez cuando una instancia de <i>Template</i>.*myTemplate* es
mostrada en nodos DOM y lo pone en el documento por primera vez, 
y de nuevo cada vez que cualquier parte de la plantilla es revisualizada.


En el cuerpo del <i>callback</i>, `this` es un objeto [template
instance](#template_inst) que es único en esta ocurrencia de
la plantilla y persiste a través de revisualizaciones. Utilice los <i>callbacks</i> 
`created` y `destroyed` para realizar inicialización o limpieza en el objeto.

{{> api_box template_created}}

Este <i>callback</i> es llamado cuando una invocación de *myTemplate* representa
una nueva ocurrencia de la plantilla y no una representación de una existente 
instancia de plantilla.  Dentro del <i>callback</i> , `this` es el nuevo objeto [template
instance](#template_inst). Las propiedades que usted puede establecer en este objeto
serán visible desde los <i>callbacks</i>  `rendered` y `destroyed` y desde 
los manipuladores de eventos.

Este <i>callback</i> se dispara una vez y es el primer <i>callback</i> que se dispara. Cada
`created` tiene un correspondiente `destroyed`; es decir, si se obtiene un
<i>callback</i> `created` con un cierto object de instancia de plantilla en `this`,
usted eventualmente obtendrá un <i>callback</i> `destroyed` para el mismo objeto.

{{> api_box template_destroyed}}

This <i>callback</i> es llamado cuando una occurrencia de una plantilla es sacado fuera de
la página por cualquier motivo y no se sustituye con una nueva re-representación.  Dentro 
del <i>callback</i>, `this` es el objeto [template instance](#template_inst) que será 
destruido.

Este <i>callback</i> es más útil para limpiar o deshacer los efectos externos de
`created`.  Se dispara una vez y es el último <i>callback</i> en ser disparado.


{{> api_box template_events}}

Declarar controladores de eventos para las instancias de esta plantilla.
Multiple llamadas añaden nuevos controladores de eventos sumandolos
a los existentes.

Ver [Event Maps](#eventmaps) para una descripción detallada del formato de mapa eventos
y de cómo la gestión de eventos trabaja en Meteor.

{{> api_box template_helpers}}

Cada plantilla tiene un diccionario local de auxiliares que están disponibles en la misma,
y esta llamada especifica auxiliares para añadir al dictionario de plantillas.

Ejemplo:

    Template.myTemplate.helpers({
      foo: function () {
        return Session.get("foo");
      }
    });

En <i>Handlebars</i>, este auxiliar se invoca como `{{dstache}}foo}}`.

La siguiente sintaxis es equivalente pero no funciona para las propiedades reservadas 
de nombres:

    Template.myTemplate.foo = function () {
      return Session.get("foo");
    };

{{> api_box template_preserve}}

Usted puede "preservar" un elemento DOM  durante la re-representación, dejando el
elemento existente en el lugar del documento mientras se sustituye el código HTML 
circundante.
Esto significa que una re-representación de plantilla no tiene por qué
estorbar los campos de texto, <i>iframes</i>, y otros elementos sensitivos 
que contenga.  Los elementos a preservar deben estar presentes tanto como nodos en
el viejo DOM y como <i>tags</i> en el nuevo HTML.  Meteor parcheará el DOM
basándose en los elementos conservados.

{{#note}}
Pot defecto, las nuevas <i>apps</i> Meteor automaticamente incluyen el
paquete `preserve-inputs`.  Todos estos elementos preservados de tipo
`input`, `textarea`, `button`, `select`, y `option` que tienen un único atributo
`id` o que tienen atributos `name` únicos dentro de un 
un elemento que lo encierra con un atributo `id`.  Para desactivar 
este comportamiento por defecto, simplemente borre el paquete `preserve-inputs`.
{{/note}}

Preservar es útil en varietad de casos en los que reemplazar un elemento DOM
con un idéntico o elemento modificado no tendría el mismo efecto 
que retener el elemento original.  Estos incluyen:

* Campos <i>Input text</i> y otros controles de formulario
* Elementos con animaciones CSS
* Iframes
* Nodos con referencias que se encuentran en el código JavaScript

Si desea preservar una región completa del DOM, un elemento y sus 
hijos, o nodos no representados por Meteor, utilice en su lugar un [constant
region](#constant).

Para preservar nodos, pase una lista de selectores, cada una de ellas debe coincidir
por lo menos con un elemento en la plantilla.  Cuando la plantilla es re-visualizada,
el selector es ejecutado en el viejo DOM y el nuevo DOM, y Meteor reutilizará
el viejo elemento en su lugar mientras se trabajan cambios en todo el código HTML.

Una segunda forma de `preserve` toma una función de etiquetado para cada selector
y permite que los selectores coincidan con varios nodos. La función etiquetado de nodos
toma un nodo y retorna una cadena etiqueta que es única para cada nodo
o `false` para excluir el nodo de ser preservado.

Por Ejemplo, para preservar todos los elementos <code>`<input>`</code>  
con <i>ids</i> la plantilla 'foo', utilice:

    Template.foo.preserve({
      'input[id]': function (node) { return node.id; }
    });

Los selectores son interpretados como <i>rooted</i> de nivel superior de la plantilla.
Cada ocurrencia de la plantilla funciona de forma independiente, por lo que los selectores
no tienen que ser únicos en toda la página, sólo dentro de una ocurrencia de la plantilla.
Los selectores coincidirán con los nodos, incluso si están en sub-plantillas.

Preservar un nodo *no* preserva sus atributos o contenidos. Ellos 
se actualizarán para reflejar el nuevo HTML. El texto en campos <i>input</i> no es 
preservado a menos que el campo <i>input</i> tenga el foco, en tal caso el cursor y
la seleción se dejan intactos. <i>Iframes</i> retienen su estado de navegación y
las animaciones continuarán funcionando siempre y cuando sus parámetros no hayan cambiado.

Hay algunos casos en que los nodos no pueden ser preservados debido a
las limitaciones inherentes a la API DOM. Por Ejemplo, un <i>tag name</i> de elemento 
no puede ser cambiado, y no puede ser movido en relación a sus padres o otros nodos
preservados. Por esta razón, los nodos que están  re-ordenados o 
re-emparentados por una actualización no serán preservados.

{{#note}}
Las versiones anteriores de Meteor tenían un implícito <i>page-wide</i> `preserve`
Esta directiva que etiquetaba nodos por sus atributos "id" y "name".
Ha sido eliminado en favor del mecanismo explícito <i>opt-in</i>.
{{/note}}


<h2 id="template_inst"><span>Template instances</span></h2>

Un objeto de instancia de plantilla representa una ocurrencia de una plantilla en el
documento.  Se puede utilizar para acceder al DOM y se pueden asignadar
propiedades que persisten a través de la revisualización de la página.

Los objetos de una instancia de plantilla se encuentran como el valor de  `this` en la
plantilla <i>callbacks</i> `created`, `rendered`, y `destroyed` y como 
argumento para controladores de eventos.

Además de las propiedades y funciones que se describen a continuación, puede
asignar propiedades adicionales de su elección en el objeto. Los nombres de propiedades
comienzan con `_` están garantizados para que esten disponibles para su uso 
Utilice el <i>callbacks</i>  `created` y `destroyed` para realizar la inicialización o
limpieza en el objeto.

Sólo puede acceder a `findAll`, `find`, `firstNode`, y `lastNode`
desde el <i>callback</i> `rendered` y desde el manipulador de eventos, no desde `created`
y `destroyed`, porque requieren que la instancia de la plantilla  esté 
en el DOM.

{{> api_box template_findAll}}

Devuelve un <i>array</i> de elementos DOM  que coincidan con el `selector`.

La instancia de plantilla sirve como el documento raiz para el selector. Sólo
los elementos dentro de la plantilla y en sus sub-plantillas pueden coincidir con partes 
del selector.

{{> api_box template_find}}

Devuelve un elemento DOM a juego con `selector`, o `null`  si no existen 
tales elementos.

La instancia de plantilla sirve como el documento raiz para el selector. Sólo
los elementos dentro de la plantilla y en sus sub-plantillas pueden coincidir con partes 
del selector.

{{> api_box template_firstNode}}

Los dos nodos `firstNode` y `lastNode` indican el alcance de la plantilla 
visualizada en el DOM. La plantilla  visualizada incluye Estos dos nodos 
son hermanos (tienen el mismo padre), y `lastNode` viene después de 
`firstNode`, o sino son el mismo nodo.

{{> api_box template_lastNode}}

{{> api_box template_data}}

Esta propiedad proporciona acceso al contexto de los datos en el nivel superior de
la plantilla. Se actualiza cada vez que la plantilla es re-visualizada.
El acceso es de solo-lectura y no-reactivo.


{{> api_box render}}

`Meteor.render` crea un `DocumentFragment` (una secuencia de nodos DOM)
que se actualiza automaticamente en tiempo real. La mayoría de las aplicaciones no necesitan 
llamar a esto directamente; utilizan plantillas y Meteor maneja la visualización.

Pase una función `htmlFunc`, que retorna una cadena HTML. 
`Meteor.render` llama la función y convierte la salida en
nodos DOM. Mientras tanto, hace un seguimiento de los datos que se utilizan cuando `htmlFunc`
se ejecuta, y automaticamente conecta <i>callbacks</i> de modo que cada vez que alguno de los
datos cambie, `htmlFunc` se re-ejecuta y los nodos DOM se actualizan en su lugar.

Puede insertar el retornado `DocumentFragment` directamente en el DOM
dondequiera que desee que aparezca. Los nodos insertados continuarán
actualizandose hasta que se retiren de pantalla. Luego se limpianrán automáticamente.
Para más detalles sobre la limpieza, consulte [`Deps.flush`](#deps_flush).

`Meteor.render` hace un seguimiento de los datos de dependencies de `htmlFunc` ejecutándolo
en una computación reactiva, para que  pueda responder a los cambios en cada fuente de
datos reactivos utilizados por esta función. Para ampliar información, o aprender
como hacer su propias fuentes de datos reactivos, Ver
[Reactivity](#reactivity).

Ejemplo:

    // Client side: show the number of players online.
    var frag = Meteor.render(function () {
      return "<p>There are " + Players.find({online: true}).count() +
        " players online.</p>";
    });
    document.body.appendChild(frag);

    // Server side: encontrar todos los jugadores que han estado inactivos durante un tiempo,
    // ​​y marcarlos como fuera de línea.  El recuento en la pantalla se actualizará
    // automaticamente en todos los clientes.
    Players.update({idleTime: {$gt: 30}}, {$set: {online: false}});

{{> api_box renderList}}

Crea un `DocumentFragment` que automaticamente se actualiza en cuanto los resultados
de la consulta a la base de datos cambia. La mayoría de las aplicaciones Meteor utilizan 
`{{dstache}}#each}}` en una plantilla en vez de llamarlo directamente.

`renderList` es más eficiente que el uso de `Meteor.render` para representar HTML
de una lista de documentos.  Por Ejemplo, si un documento nuevo se crea en
la base de datos que coincida con la consulta, un nuevo elemento se representará e 
insertará en el lugar apropiado en el DOM sin re-revisualizar los otros elementos. 
Del mismo modo, si un documento cambia de posición en un consulta ordenada, 
los nodos DOM se moverán y no se volverán a representar.

`docFunc` se llama asi cuando se necesita para generar código HTML para cada documento. 
Si usted proporciona `elseFunc`, entonces siempre que la consulta no devuelva ningún resultado,
será llamado para visualizar contenido alternativo. puede usar esto para mostrar 
un mensaje como "Ningún registro coincide con su consulta."

Cada llamada a `docFunc` o `elseFunc` se ejecuta en su propia computación reactiva
de manera que si tiene otras dependencias de datos externos, será
individualmente re-ejecutado cuando los datos cambien.

Ejemplo:

    // Lista los títulos de todos los puestos que tienen la etiqueta
    // "frontpage". Mantiene la lista actualizada cuando los se hacen nuevos mensajesew posts, como etiquetas
     // cambio, etc.  Muestra el mensaje seleccionado de manera diferente.
    var frag = Meteor.renderList(
      Posts.find({tags: "frontpage"}),
      function(post) {
        var style = Session.equals("selectedId", post._id) ? "selected" : "";
        // En una aplicación real habría que  habría que citar / sanear  post.name
        return '<div class="' + style + '">' + post.name + '</div>';
      });
    document.body.appendChild(frag);

    // Selecciona un mensaje.  Esto causará que sólo el elemento seleccionado y el
    // elemento seleccionado previamente se actualicen.
    var somePost = Posts.findOne({tags: "frontpage"});
    Session.set("selectedId", somePost._id);


{{#api_box_inline eventmaps}}

Varias funciones toman mapas de eventos. Un mapa de eventos es un objeto donde 
las propiedades especifican un conjunto de eventos para manejar, y los valores son los
manejadores para estos eventos. La propiedad puede ser una de estas formas:


<dl>
{{#dtdd "<em>eventtype</em>"}}
Coincide con un tipo particular de evento, como 'click'.
{{/dtdd}}

{{#dtdd "<em>eventtype selector</em>"}}
Coincide con un tipo particular de evento, pero sólo cuando aparece en un
elemento que cumpla con un determinado selector CSS.
{{/dtdd}}

{{#dtdd "<em>event1, event2</em>"}}
Para manejar más de un tipo de evento con la misma función, utilice
una lista separada por comas.
{{/dtdd}}
</dl>

La función controladora recibe dos argumentos: `event`, un objeto con
información sobre el evento, y `template`, una [template
instance](#template_inst) para la plantilla donde se define el controlador.
El controlador también recibe algunos datos de contexto adicionales en
`this`, dependiendo del contexto del elemento actual se maneja el evento.
En una plantilla <i>Handlebars</i>, un contexto de elemento es el
dato de contexto <i>Handlebars</i> donde sucede ese elemento, que se establece por
bloques auxiliares como `#with` y `#each`.

Ejemplo:

    {
      // Se activa cuando se hace clic en cualquier elemento
      'click': function (event) { ... },

      // Se activa cuando cualquier elemento con la clase 'accept' es clicado
      'click .accept': function (event) { ... },

      // Se activa cuando se hace clic en 'accept' o se presiona una tecla
      'keydown, click .accept': function (event) { ... }
    }

La mayoría de los eventos se propagan por el arbol del documento 
desde su elemento de origen. Por Ejemplo, `'click p'` atrapa un clic en cualquier lugar 
en un párrafo, incluso si la pulsación se originó en un enlace, span, o algún otro
elemento dentro del párrafo.  El elemento de origen del evento 
está disponible como característica `target`, mientras que el elemento que coincidía con
el selector y está menejado actualmente se llama `currentTarget`.

    {
      'click p': function (event) {
        var paragraph = event.currentTarget; // siempre un  <i>P</i>
        var clickedElement = event.target; // podría ser el <i>P</i> o un elemento hijo
      }
    }

Si un selector coincide con multiples elementos que un evento propague, 
se le llamará varias veces, por Ejemplo en el caso de `'click
div'` o `'click *'`. Si ningún selector es dado, el controlador 
sólo se llama una vez, en la etiqueta original del elemento.

Las siguientes propiedades y métodos están disponibles en el objeto evento
pasado al controlador:

<dl class="objdesc">
{{#dtdd name="type" type="String"}}
El tipo de evento, como por ejemplo "click", "blur" o "keypress".
{{/dtdd}}

{{#dtdd name="target" type="DOM Element"}}
El elemento que originó el evento.
{{/dtdd}}

{{#dtdd name="currentTarget" type="DOM Element"}}
El elemento que actualmente maneja el evento.  Este es el elemento que 
coincidió con el selector en el mapa de eventos. Para eventos que se propagan, puede
ser `target` o un ancestro de `target`, y su valor cambia en cuanto
el evento se propaga.
{{/dtdd}}

{{#dtdd name="which" type="Number"}}
Para los eventos del ratón, el número del botón del ratón (1=izquierda, 2=medio, 3=derecha).
Par eventos de teclado, un caracter o codigo de tecla.
{{/dtdd}}

{{#dtdd "stopPropagation()"}}
Para impedir que el evento se propague (burbujee) hasta otros elementos.
Otros manejadores de eventos que coincidan con el mismo elemento y estén lanzados todavía, en
este y otros mapas de eventos.
{{/dtdd}}

{{#dtdd "stopImmediatePropagation()"}}
Impiden que todos los manejadores de eventos adicionales que se ejecuten en este evento,
incluyendo otros manejadores de este mapa de eventos, los manipuladores alcanzados por
la propagación, y manejadores en otros mapas de eventos.
{{/dtdd}}

{{#dtdd "preventDefault()"}}
Impide la acción que el navegador tendria normalmente en respuesta a este 
evento, como seguir un enlace o enviar un formulario. Controladores adicionales 
todavía son llamados, pero no pueden revertir el efecto. 
{{/dtdd}}

{{#dtdd "isPropagationStopped()"}}
Devuelve si `stopPropagation()` ha sido llamado para este evento.
{{/dtdd}}

{{#dtdd "isImmediatePropagationStopped()"}}
Devuelve si `stopImmediatePropagation()` ha sido llamado para este evento..
{{/dtdd}}

{{#dtdd "isDefaultPrevented()"}}
Devuelve si `preventDefault()` ha sido llamado para este evento.
{{/dtdd}}
</dl>

Devuelve `false` de un manejador que es el mismo que llamar a la vez
`stopImmediatePropagation` y `preventDefault` en el evento.

Tipos de eventos y usos incluye:

<dl class="objdesc">
{{#dtdd "<code>click</code>"}}
Pulse con el ratón en cualquier elemento, incluyendo un enlace, botón, control de formulario, o un <i>div</i>.
Utilice `preventDefault()` para evitar que al clicar un enlace sea sequido.
Algunas formas de activar un elemento desde el teclado también lanza `click`.
{{/dtdd}}

{{#dtdd "<code>dblclick</code>"}}
Double-click.
{{/dtdd}}

{{#dtdd "<code>focus, blur</code>"}}
Un campo <i>input</i> de texto u otro control de formulario gana o pierde el foco.
Puede hacer cualquier elemento enfocable dándole una propiedad `tabindex`.
Los navegadores difieren sobre si <i>links, checkboxes, </i>y <i>radio buttons</i> son
nativamente enfocables. Estos eventos no son propagables.
{{/dtdd}}

{{#dtdd "<code>change</code>"}}
Un <i>checkbox</i> o <i>radio button</i> cambia de estado. Para campos de texto, utilice
`blur` o eventos de teclado para responder a cambios.
{{/dtdd}}

{{#dtdd "<code>mouVernter, mouseleave</code>"}} El puntero entra o 
sale de los límites de un elemento. Estos eventos no son propagables.
{{/dtdd}}

{{#dtdd "<code>mousedown, mouseup</code>"}}
El botón del ratón está recién pulsado o soltado.
{{/dtdd}}

{{#dtdd "<code>keydown, keypress, keyup</code>"}}
El usuario pulsa una tecla del teclado.  `keypress` es más útil para la captura de
pulsaciones en un campo de texto, mientras que `keydown` y `keyup` pueden ser 
utilizado por las teclas flecha o las teclas modificadoras.
{{/dtdd}}
</dl>

Otros eventos DOM están disponibles también, pero ante estos eventos,
Meteor ha tomado un poco de cuidado para asegurarse de que funcionan de 
manera uniforme en todos los navegadores.

{{/api_box_inline}}



{{#api_box_inline constant}}

Puede marcar una región de una plantilla como "constant"  y no someterse a un
re-visualizado utilizando el bloque auxiliar
`{{dstache}}#constant}}...{{dstache}}/constant}}`.
El contenido dentro del bloque auxiliar `#constant` se conserva exactamente tal y como es,
incluso si encerrando la plantilla es re-visualizada. Los cambios en otras partes de la
plantilla están parcheados ​​en torno a ella de la misma manera como
`preserve`. A diferencia de la preservación de un nodo individual, una region constante 
retiene no sólo las identidades de sus nodos, sino también sus atributos y contenidos. 
El contenido del bloque sólo se evalua una vez por ocurrencia de la plantilla encerrada.

Las regiones constantes permiten que contenido <i>non-Meteor</i> sea embebido en una plantilla Meteor
Muchos widgets de terceros crean y gestionan sus propios nodos DOM 
mediante programación.Por lo general, se pone un elemento vacio en su 
plantilla, que el widget o biblioteca luego poblará con hijos DOM. 
Normalmente, cuando Meteor se vuelve a representar, la plantilla encerrada
borrará  los nuevos hijos DOM, ya que la plantilla especifica que debe estar vacío.
Si se envuelve en un bloque `#constant`, sin embargo, se deja solo; 
cualquiera que sea el contenido que se encuentre en los restos del DOM.

{{#note}}
Las regiones constantes se destinan a incorporar contenido No-Meteor.
Los controladores de eventos y las dependencias reactivas actualmente no funcionan
correctamente dentro de las regiones constantes.
{{/note}}


{{/api_box_inline}}

{{#api_box_inline isolate}}

Cada plantilla se ejecuta como su propia computación reactiva.  Cuando la plantilla tiene 
acceso a una fuente de datos reactivo, tales como llamar `Session.get` o
hacer una consulta de base de datos, esto establece dependencia de datos que hará que
cause que la totalidad de la plantilla se vuelva a re-representar cuando los datos cambien.
Esto significa que la cantidad de re-presentación para un cambio particular
se ve afectada por como ha dividido su código HTML en plantillas.

Típicamente, la extensión exacta de re-presentación no es crucial, pero si quiere
más control, por motivos de rendimiento, puede utilizar el auxiliar
`{{dstache}}#isolate}}...{{dstache}}/isolate}}`. los datos de dependencias establecidos 
en el interior de un bloque `#isolate` están localizados en el
bloque y no en sí mismos causa que la plantilla padre sea
re-representada. Este bloque auxiliar esencialmente transmite los beneficios de la 
reactividad que obtendría tirando el contenido hacia una nueva sub-plantilla.

{{/api_box_inline}}


<h2 id="timers"><span>Timers</span></h2>

Meteor utiliza variables de entorno globales para controlar las cosas como
la solicitud actual del usuario. Para asegurarse de que
estas variables tienen los valores corectos, necesita utilizar
`Meteor.setTimeout` en vez de `setTimeout` y `Meteor.setInterval`
en vez  de `setInterval`.

Estas funciones trabajan justo igual que sus equivalentes JavaScript nativas.
Obtendrá un error si llama a la función nativa.

{{> api_box setTimeout}}

Devuelve un identificador que puede ser utilizado por `Meteor.clearTimeout`.

{{> api_box setInterval}}

Devuelve su manejador que puede ser utilizado por `Meteor.clearInterval`.

{{> api_box clearTimeout}}
{{> api_box clearInterval}}

<h2 id="deps"><span>Deps</span></h2>

Meteor tiene un simple sistema de dependencia de seguimiento que le permite
volver a ejecutar automáticamente las plantillas y otros computos cuando
[`Session`](#session) variables, consultas de bases de datos, y otros fuentes 
de datos cambia.

A diferencia de la mayoría de los otros sistemas, usted no tiene que
declarar manualmente estas dependencias &mdash; que "simplemente funciona". 
El mecanismo es sencillo y eficiente.
Cuando llama una función que admite actualizaciones reactivas
(Por ejemplo, una consulta de base de datos), que guarda automáticamente el actual
objeto <i>Computation</i>, en su caso (que representa, por Ejemplo, la plantilla actual
siendo viualizada). Más tarde, cuando los datos cambian, la función
puede "invalidate" el <i>Computation</i>, haciendo que se vuelva a ejecutar (reevisualizando la
plantilla).

Las aplicaciones encontrarán [`Deps.autorun`](#deps_autorun) útil, mientras más 
servicios avanzados tales como `Deps.Dependency` y `onInvalidate`
<i>callbacks</i> están destinados principalmente a los autores de paquetes que implementan
nuevas fuentes de datos reactivas.

{{> api_box deps_autorun }}

`Deps.autorun` le permite ejecutar una función que depende de fuentes de 
datos reactivos de tal manera que si hay cambios en los datos más adelante,
la función se vuelve a ejecutar. .

Por Ejemplo, puede monitorizar un cursor (que es una fuentes de datos 
reactiva) y agregarlos a una variable de sesión:

    Deps.autorun(function () {
      var oldest = _.max(Monkeys.find().fetch(), function (monkey) {
        return monkey.age;
      });
      if (oldest)
        Session.set("oldest", oldest.name);
    });

 o puede esperar que una variable de sesión tenga un cierto valor, y haga
algo la primera vez que lo hace, llamando `stop` en la computación para
evitar posteriores reejecuciones:

    Deps.autorun(function (c) {
      if (! Session.equals("shouldAlert", true))
        return;

      c.stop();
      alert("Oh no!");
    });

La función se invoca inmediatamente, de tal manera que se puede alertar y
detener de inmediato si `shouldAlert` es ya <i>true</i>.  Si no, la
función se ejecuta de nuevo cuando `shouldAlert` se convierte en <i>true</i>.

Un cambio en una dependencia de datos no provoca una immediata reejecución, sino
que "invalida" la computación, causando que se vuelva a ejecutar la próxima
vez que se produce una descarga.  Una descarga se producirá automáticamente tan pronto como 
el sistema está inactivo si no se invalidan los computos. También puede utilizar
[`Deps.flush`](#deps_flush) para causar una descarga inmediata de
todas las reposiciones pendientes. .

Si anida llamadas a `Deps.autorun`, entonces cuando la llamada externa se detenga o
se reejecute, la llamada interna se detendrá automáticamente. Las suscripciones y 
los observadores también se detiene automáticamente cuando se utiliza como parte de 
un cálculo que se vuelve a ejecutar, permitiendo que los nuevos se establezcan.  Ver
[`Meteor.subscribe`](#meteor_subscribe) para obtener más información acerca 
de las suscripciones y la reactividad.

Si la ejecución inicial de un <i>autorun</i> produce una excepción, la computación 
se detiene automáticamente y no se vuelve a ejecutar.

{{> api_box deps_flush }}

Normalmente, al hacer cambios (como escribir a la base de datos),
su impacto (como la actualización del DOM) se retrasa hasta que el sistema esté inactivo.
Esto mantiene las cosas predecibles &mdash; puede saber que el DOM
no va a cambiar por debajo de su código a medida que se ejecuta.
Es también una de las cosas que hace a Meteor rápido.

`Deps.flush` obliga todas las actualizaciones reactivas pendientes a completarse.
Por Ejemplo, si un controlador de eventos cambia una variable de sesión que causará
que se vuelva a procesar parte de la interfaz de usuario  el controlador
puede llamar  `flush` para realizar la revisualización inmediatamente y luego 
aceder al DOM resultante .

Una limpieza automática se produce cuando el sistema está inactivo lo cual realiza
exactamente el mismo trabajo que `Deps.flush`.  El proceso de limpieza consiste 
en reejecutar cualquier computación invalidada.  Si invalidaciones adicionales 
suceden durante la limpieza, se procesan como parte de la misma limpieza hasta
que no hay más trabajo por hacer. <i>callbacks</i> registradas con 
[`Meteor.afterFlush`](#deps_afterflush) se llaman después de procesar 
invalidaciones pendientes.

Cualquier auto-actualización de elementos DOM que se observa que no estan en el 
documento durante una descarga pueden ser limpiados por Meteor (Lo que significa que
Meteor dejará de seguir y actualizar elementos, por lo que
el colector de basura del navegador puede eliminarlos) Así que, si llama
manualmente `flush`, necesita asegurarse de que cualquier auto-actualización de elementos
que haya creado llamando [`Meteor.render`](#meteor_render)
ya se han insertado en el árbol DOM principal.

Es ilegal llamar `flush` desde el interior de un `flush` o de una computación
en ejecución.

{{> api_box deps_nonreactive }}

Llamadas `func()` con `Deps.currentComputation` temporalmente se establecen a 
`null`.  Si `func` accede a fuentes de datos reactivos, estas fuentes de datos
nunca causarán reejecución de la computación envolvente.

{{> api_box deps_active }}

Este valor es útil para implementaciones de fuentes de datos que determinan
si están siendo accedidos reactivamente o no.

{{> api_box deps_currentcomputation }}

Es muy raro necesitar acceder a `currentComputation` directamente.  La
computación actual se utiliza implícitamente por
[`Deps.active`](#deps_active) (Que comprueba si hay uno),
[`dependency.depend()`](#dependency_depend) (que registra que depende de una 
dependencia), y [`Deps.onInvalidate`](#deps_oninvalidate) (Que 
registra un <i>callback</i> con el mismo).

{{> api_box deps_oninvalidate }}

Ver [*`computation`*`.onInvalidate`](#computation_oninvalidate) para obtener más
detalles.

{{> api_box deps_afterflush }}

Funciones programadas por múltiples llamadas a `afterFlush` llamadas para
que funcionen en el orden en que `afterFlush` ha sido llamado. Las funciones están
garantizadas que serán llamadas en el momento que no se hayan invalidado 
los cálculos que deben volver a ejecutar. Esto significa que si una
función `afterFlush` invalida una computación, esta computación se reejecuta
antes que cualquier otra función `afterFlush` sea llamada.

<h2 id="deps_computation"><span>Deps.Computation</span></h2>

Un objeto <i>Computation</i> representa código que es repetidamente reejecutado en
respuesta a los cambios de datos reactivos. <i>Computations</i> no tienen valores de retorno
sino que sólo llevan a cabo acciones, como rerepresentar una plantilla en la
pantalla.  <i>Computations</i> se crean utilizando [`Deps.autorun`](#deps_autorun).
Utilice [`stop`](#computation_stop) para evitar adicionales reejecuciones de una
computación.

Cada vez que se ejecuta una computación, puede acceder a varias fuentes de datos
reactivos que sirven como entradas para la computación, de las que son llamadas sus 
dependencias. En algún tiempo futuro, una de estas dependencias
desencadenará que la computación se vuelva a ejecutar invalidando la misma.  Cuando esto
sucede, las dependencias se borran, y la computación es
programada para volver a ejecutarse en tiempo de limpieza.

La *current computation* ([`Deps.currentComputation`](#deps_currentcomputation)) es la
computación que se está ejecutando actualmente o reejecutando (computed), y de la que se
obtiene una dependencia cuando se accede a una fuente de datos reactiva.
Las fuentes de datos son los responsables para el seguimiento de estas dependencias mediante 
los objetos [`Deps.Dependency`](#deps_dependency).

Al invalidar una computación se establece su propiedad `invalidated` a true
e inmediatamente llama  a todos los <i>callbacks</i> `onInvalidate` de computación.
Cuando una limpieza sucede, si la computacion ha sido invalidada 
y no detenida, entonces la computación es reejecutada mediante el establecimiento 
de la propiedad `invalidated` a `false` y llamando a la funcion original
que fué pasada  a `Deps.autorun`. Una limpieza sucederá cuando el actual
código termine de ejecutarse, o antes si se llama `Deps.flush`.

Deteniendo una computación lo invalida (si es válido) con el propósito
de llamar <i>callbacks</i>, pero asegura que nunca se vuelva a ejecutar.

Ejemplo:

    //  si estamos en una computación, entonces realiza alguna limpieza
    //cuando se invalida la actual computación (reejecutada o
    // detenida)
    if (Deps.active) {
      Deps.onInvalidate(function () {
        x.destroy();
        y.finalize();
      });
    }

{{> api_box computation_stop}}

La detención de una computación es irreversible y garantiza que nunca
se vuelva a ejecutar.  Puede detener una computación en cualquier momento, incluyendo
desde la propia función que gestióna la computación. La detención de una computación que
ya se ha detenido no tiene ningún efecto. 

La detención de una computación causa que su <i>callbacks</i> `onInvalidate` se 
ejecute inmediatamente si no está ya actualmente ivalidado.

Las computaciones anidadas se detienen automaticamente cuando su computación
adjunta se vuelve a ejecutar.

{{> api_box computation_invalidate }}

Invalidando una computación lo marca para ser reejecutado por
[flush time](#deps_flush), en este punto la computación 
se vuelve válida nuevamente.  Es raro invalidar una computación 
manualmente, ya que las fuentes de datos reactivas
invalidan sus llamadas computacionales cuando cambian. Fuentes de datos
reactivos, a su vez realizan esta invalidación usando uno o más 
objetos b[`Deps.Dependency`](#deps_dependency).

Invalidando una computación inmediatamente llama todos los <i>callbacks</i> `onInvalidate`
registrados en el. Invalidando una computación que actualmente
ya está invalidada o está detenida no tiene efecto.  Unas computación puede
invalidarse a si mismo, pero si se continúa haciéndolo indefinidamente, el 
resultado será un bucle infinito.

{{> api_box computation_oninvalidate }}

`onInvalidate` registra una sola vez <i>callback</i> que o bien ejecuta
immediatamente o tan pronto como la computación próxima se invalida o se detiene. 
Se utiliza por las fuentes de datos reactivas para limpiar los recursos o
interrumpir dependencias cuando la computación es reejecutada o detenida.

Para obtener un <i>callback</i> después de que una computación ha sido recalculada, puede
llamar [`Deps.afterFlush`](#deps_afterflush) desde `onInvalidate`.

{{> api_box computation_stopped }}

{{> api_box computation_invalidated }}

Esta propiedad es inicialmente <i>false</i>.  Se fija en <i>true</i> por `stop()` y
`invalidate()`.  Se restablece en <i>false</i> cuando la computación es
recalculada en tiempo de limpieza.

{{> api_box computation_firstrun }}

Esta propiedad es una conveniencia para apoyar el patrón común donde una
computación tiene una lógica específica de la primera ejecución.

<h2 id="deps_dependency"><span>Deps.Dependency</span></h2>

Una <i>Dependencia</i> representa una unidad atómica de datos reactivos de la que una
computacion pueda depender. Fuentes de datos reactivos tales como <i>Session</i> o
<i>Minimongo</i> crean internamente diferentes objetos <i>Dependency</i>  para diferentes
piezas de datos, cada uno de los cuales puede depender de multiples
computaciones.  Cuando los datos cambian, la computaciones son
invalidadas.

Las Dependencias no almacenan datos, sólo el seguimiento del conjunto de las computaciones para
invalidar si algo cambia. Típicamente, un valor de datos será acompañado por un objeto 
<i>Dependency</i> que rastrea las computaciones que dependen de ella,
como en este Ejemplo:

    var weather = "sunny";
    var weatherDep = new Deps.Dependency;

    var getWeather = function () {
      weatherDep.depend()
      return weather;
    };

    var setWeather = function (w) {
      weather = w;
      // (podría agregar lógica para llamar sólo a changed()
      // nuevo valor es diferente de la antigua)
      weatherDep.changed();
    };

Este ejemplo implementa una fuente de datos con un simple <i>getter</i> y
<i>setter</i>.  Los registros  <i>getter</i>  de las que depende la actual computación
en la dependencia `weatherDep` utiliza `depend()`, mientras que <i>setter</i>
señala la dependencia  al invalidar todos las cálculos dependientes llamando `changed()`.

La razón de que las <i>Dependencies</i> no almacenan datos ellas mismas es que puede 
ser útil  asociar múltiples <i>Dependencies</i> con la mismo pieza de información.
Por Ejemplo, una dependencia podría representar el resultado de una consulta de
base de datos, mientras que otra puede representar sólo el número de documentos 
en el resultado. Una <i>Dependency</i> podría representar clima, el clima es soleado 
o no, o la temperatura del clima está por encima de la congelación.
[`Session.equals`](#session_equals) se lleva a cabo de esta manera para 
eficiencia.  Cuando llama  `Session.equals("weather", "sunny")`, la actual
computación se hace depender de una  <i>Dependency</i> interna que
no cambia si el clima va desde, digamos, "lluvioso" a "nublado".

Conceptualmente, las únicas dos cosas que una <i>Dependency</i> puede hacer es obtener un
dependiente y cambiar.

Los cálculos que dependen de una <i>Dependency</i> son siempre válidos (tienen
`invalidated === false`).  Si un dependiente es invalidado en cualquier momento,
ya sea por la propia <i>Dependency</i> o de otra manera, es
inmediatamente eliminado.

{{> api_box dependency_changed }}

{{> api_box dependency_depend }}

`dep.depend()` se utiliza en implementaciones de código de datos reactivos para registrar 
el hecho de que `dep` está siendo accedido desde la actual computación.

{{> api_box dependency_hasdependents }}

Para las fuentes de datos de reactivos que crean muchas <i>Dependencies</i>
internas, esta función es útil para determinar si una dependencia particular 
está todavía rastreando cualquier relación de dependencia o si se puede 
limpiar para ahorrar memoria.

<h2 id="ejson"><span>EJSON</span></h2>

EJSON es una extensión de <i>JSON</i> para soportar más tipos. Es compatible con todos
los tipos <i>JSON-safe</i> como:

 - **Date** (JavaScript `Date`)
 - **Binary** (JavaScript `Uint8Array` or the
   result of [`EJSON.newBinary`](#ejson_new_binary))
 - **User-defined types** (Ver [`EJSON.addType`](#ejson_add_type).  Por ejemplo,
 [`Meteor.Collection.ObjectID`](#collection_object_id) se implementa de esta manera.)

Todas las serializaciones <i>EJSON</i> son tambien JSON válido.  Por ejemplo un objeto con una fecha
y un búfer binario que se va a serializar en <i>EJSON</i> como:

    {
      "d": {"$date": 1358205756553},
      "b": {"$binary": "c3VyZS4="}
    }

Meteor soporta todos los tipos de datos construidos en <i>EJSON</i>  publicadores, argumentos de método 
y resultados, bases de datos Mongo, y variables de [`Session`](#session) .

{{> api_box ejsonParse}}

{{> api_box ejsonStringify}}

{{> api_box ejsonFromJSONValue}}

{{> api_box ejsonToJSONValue}}

{{> api_box ejsonEquals}}

{{> api_box ejsonClone}}

{{> api_box ejsonNewBinary}}

Los <i>Buffers</i> de datos binarios son representados por instancias `Uint8Array` en 
plataformas JavaScript que los soporta. En las implementaciones de JavaScript que no 
soportan `Uint8Array`, los búfers de datos binario se representan por <i>arrays</i>
estandar que contienen números con rangos desde 0 a 255, y la tecla `$Uint8ArrayPolyfill` se
establece a `true`.

{{> api_box ejsonAddType}}

Cuando añada un tipo de <i>EJSON</i>, Meteor será capaz de utilizar ese tipo en:

 - la publicación de objetos de su tipo si pasa a publicar controladores.
 - permitiendo el tipo de los valores de retorno o argumentos a
   [methods](#methods_header).
 - almacenar el tipo de <i>client-side</i> en <i>Minimongo</i>.
 - permitiendo su tipo de variables [`Session`](#session).

{{#note}}
  <i>MongoDB</i> no puede almacenar más tipos definidos por el usuario de forma nativa en el servidor.
    Su tipo funcionará en <i>Minimongo</i>, y usted puede enviarlo al cliente utilizando el
  publicador acostumbrado, pero MongoDB sólo puede almacenar los tipos definidos en
  [BSON](http://bsonspec.org/).
{{/note}}

Las instancias de su tipo implementarán la siguiente interfaz:

{{> api_box ejsonTypeClone}}

{{> api_box ejsonTypeEquals}}

El método `equals` debe definir una [equivalence
relation](http://en.wikipedia.org/wiki/Equivalence_relation).  Debe tener 
las siguientes propiedades: 

 - *Reflexivity* - por cada instancia `a`: `a.equals(a)` debe ser <i>true</i>.
 - *Symmetry* - para cualquiera de dos instancias `a` y `b`: `a.equals(b)` si y sólo si `b.equals(a)`.
 - *Transitivity* - para cualquiera de tres instancias `a`, `b`, y `c`: `a.equals(b)` y `b.equals(c)` 
 implica `a.equals(c)`.

{{> api_box ejsonTypeName}}
{{> api_box ejsonTypeToJSONValue}}

Por ejemplo, el método `toJSONValue` para
[`Meteor.Collection.ObjectID`](#collection_object_id) debe ser:

    function () {
      return this.toHexString();
    };

<h2 id="meteor_http"><span>Meteor.http</span></h2>

`Meteor.http` proporciona una HTTP API en el cliente y en el servidor.  Para utilizar 
estás funciones, añada el paquete HTTP a su  projecto con `$ meteor add
http`.

{{> api_box httpcall}}

Esta función inicia una petición HTTP a un servidor remoto. Devuelve
un objeto resultado con el contenido de la respuesta HTTP.  El objeto 
resultado es detallado a continuación.

En el servidor, esta función se puede ejecutar de forma sincrónica o asincrónica.
Si el <i>callback</i> es omitido se ejecuta sincrónicamente,
y los resultados son devueltos una vez que la solicitud se completa. Esto es
útil si se hace <i>server-to-server</i> HTTP API llama desde dentro del método 
Meteor, ya que el método puede tener éxito o fallar sobre la base de los resultados de la
llamada HTTP sínchrona.  En este caso, considere utilizar
[`this.unblock()`](#method_unblock) para permitir que otros métodos se ejecuten mientras tanto.  
En el cliente, esta función debe ser utilizada asincrónicamente pasando un <i>callback</i>.

Ambos protocolos HTTP y HTTPS son compatibles. El argumento `url` debe ser
una URL absoluta incluyendo protocolo y nombre de <i>host</i> en el servidor, pero puede ser
relativo al actual <i>host</i> en el cliente.  La opción `query` reemplaza
la cadena de consulta del `url`.  Los parámetros especificados en `params`
que están puestos en el URL se añaden a cada cadena de consulta.
Por ejemplo, con un `url` de `"/path?query"` y
`params` def `{foo:"bar"}`, el  URL final será `"/path?query&foo=bar"`.

Los `params` se ponen en el URL o en el cuerpo de la solicitud, dependiendo del 
tipo de solicitud.  En el caso de solicitudes sin cuerpos, como GET y
HEAD, los parámetros siempre irán en la URL.  Para un POST o otro
tipo de soilcitud, los parámetros se codifican en el <i>body</i> con un
contenido estandar de tipo `x-www-form-urlencoded`, a menos que la opción `content`
o `data` sean utilizadas para especificar un <i>body</i>, en tal caso los 
parámetros serán añadidos al URL en su lugar.

El <i>callback</i> recibe dos argumentos, `error` y `result`.  El argumento
`error` contendrá un Error si la solicitud falla de cualquier manera,
incluyendo un error de red, <i>time-out</i>, o un código de estado HTTP definido en
el rango 400 o 500.  El objeto resultado está siempre definido. 
Cuando se ejecuta en modo síncrono, el `result` es devuelto desde la
función, y el valor `error` es almacenado como una propiedad en `result`.

Contenidos del objeto de resultado:

<dl class="objdesc">

<dt><span class="name">statusCode</span>
  <span class="type">Number</span></dt>
<dd>Resultado numérico, código de estado HTTP , o <code>null</code> en error.</dd>

<dt><span class="name">content</span>
  <span class="type">String</span></dt>
<dd>El <i>body</i> de la respuesta HTTP como un <i>string</i>.</dd>

<dt><span class="name">data</span>
  <span class="type">Object o <code>null</code></span></dt>
<dd>Si las cabeceras de <i>response</i> indican contenido JSON, contiene el cuerpo del documento parseado como un objeto JSON.</dd>

<dt><span class="name">headers</span>
  <span class="type">Object</span></dt>
<dd>Un <i>dictionary</i> de cabeceras HTTP de la respuesta.</dd>

<dt><span class="name">error</span>
  <span class="type">Error</span></dt>
<dd>Error de objeto si la solicitud ha fallado. Coincide con el parameter <code>error</code> del <i>callback</i>.</dd>


</dl>

Ejemplo <i>server method</i>:

    Meteor.methods({checkTwitter: function (userId) {
      this.unblock();
      var result = Meteor.http.call("GET", "http://api.twitter.com/xyz",
                                    {params: {user: userId}});
      if (result.statusCode === 200)
         return true
      return false;
    }});

Ejemplo asynchronous HTTP call:

    Meteor.http.call("POST", "http://api.twitter.com/xyz",
                     {data: {some: "json", stuff: 1}},
                     function (error, result) {
                       if (result.statusCode === 200) {
                         Session.set("twizzled", true);
                       }
                     });


{{> api_box http_get}}
{{> api_box http_post}}
{{> api_box http_put}}
{{> api_box http_del}}


<h2 id="email"><span>Email</span></h2>

El paquete `email` permite el envío de correo electrónico desde una aplicación Meteor.
Para utilizarlo, agregue el paquete a su proyecto con `$ meteor add email`.

El servidor lee de la variable del entorno `MAIL_URL` para determinar cómo enviar
correo. Actualmente, Meteor admite el envío de correo a través de SMTP; la variable 
del entorno `MAIL_URL` debe estar en la forma `smtp://USERNAME:PASSWORD@HOST:PORT/`. 
Para desplegar <i>apps</i> con `meteor deploy`, `MAIL_URL` da por defecto una cuenta 
(proporcionado por [Mailgun](http://www.mailgun.com/)) que permite a las aplicaciones enviar hasta 200
correos electrónicos por día; puede anular este por defecto asignando `process.env.MAIL_URL`
antes de la primera llamada a `Email.send`.

Si `MAIL_URL` no se ha establecido (ej, cuando se ejecuta su aplicación a nivel local),
`Email.send` muestra en su lugar el mensaje en la salida estándar.

{{> api_box email_send }}

Debe proporcionar la opción `from` y por lo menos uno de `to`, `cc`, y `bcc`;
todas las demás opciones son opcionales. 

`Email.send` sólo funciona en el servidor. Aquí hay un ejemplo de cómo un
cliente podría utilizar la llamada a un método de servidor para enviar un <i>email</i>. 
(En una aplicación real, hay que tener cuidado en limitar los correos electrónicos que 
un cliente puede enviar, para evitar que su servidor sea utilizado como un <i>relay</i> por <i>spammers</i>.)

    // En su código del servidor: definir un método que el cliente puede llamar
    Meteor.methods({
      sendEmail: function (to, from, subject, text) {
        // Permite llamar otro método desde el mismo cliente y empezar a ejecutarse,
        //sin tener que esperar a que el envío de correo electrónico se haya completado. 
        this.unblock();

        Email.send({
          to: to,
          from: from,
          subject: subject,
          text: text
        });
      }
    });

    // En el código de cliente: <i>asynchronously</i> envía un email
    Meteor.call('sendEmail',
                'alice@Ejemplo.com',
                'bob@Ejemplo.com',
                'Hello from Meteor!',
                'This is a test of Email.send.');

{{/better_markdown}}
</template>


<template name="api_box">
<div class="api {{bare}}">
<h3 id="{{id}}">
  <a class="name selflink" href="#{{id}}">{{{name}}}</a>
{{#if locus}}
  <span class="locus">{{locus}}</span>
{{/if}}
</h3>

<div class="desc">
{{#each descr}}{{#better_markdown}}{{{this}}}{{/better_markdown}}{{/each}}
</div>

{{#if args}}
<h4>Arguments</h4>
{{> api_box_args args}}
{{/if}}

{{#if options}}
<h4>Options</h4>
{{> api_box_args options}}
{{/if}}

{{#if body}}
{{#better_markdown}}{{{body}}}{{/better_markdown}}
{{/if}}

</div>

</template>


<template name="api_box_args">
<dl class="args">
{{#each this}}
<dt><span class="name">{{{name}}}</span>
  <span class="type">
    {{#if type_link}}
      <a href="#{{type_link}}">{{{type}}}</a>
    {{else}}
      {{{type}}}
    {{/if}}
  </span></dt>
<dd>{{#better_markdown}}{{{descr}}}{{/better_markdown}}</dd>
{{/each}}
</dl>
</template>


<template name="api_section_helper">
<h2 id="{{id}}"><a href="#{{id}}" class="selflink"><span>{{name}}</span></a></h2>
</template>
